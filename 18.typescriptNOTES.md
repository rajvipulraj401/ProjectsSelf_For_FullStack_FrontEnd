### ‚ö° Pro Tip

To avoid guessing:

- Use **VS Code Markdown Preview (`Ctrl+Shift+V`)**
- Right-click the heading ‚Üí **"Copy link to heading"**
- Paste it in your TOC ‚Äî that guarantees it matches the auto-generated anchor exactly.

---

---

# üöÄ Video 0 ‚Äì HOW TO Actually Use TypeScript with React

---

## üìå Quick Start Checklist

Before diving into TypeScript theory, here's what you need to know to work on **real React + TypeScript projects**:

### ‚úÖ **1. Project Setup**

```bash
# Create new React + TypeScript project
npm create vite@latest my-app -- --template react-ts

# Or with Create React App
npx create-react-app my-app --template typescript

# Install in existing project
npm install --save-dev typescript @types/react @types/react-dom
```

### ‚úÖ **2. Essential File Extensions**

- `.tsx` - React components with JSX
- `.ts` - Pure TypeScript files (utils, services, types)
- Never use `.jsx` or `.js` in TypeScript projects

---

## üéØ **Real-World React TypeScript Patterns**

### **1. Typing React Components**

```typescript
// Functional Component with Props
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: "primary" | "secondary";
  disabled?: boolean;
  children?: React.ReactNode;
}

const Button: React.FC<ButtonProps> = ({
  label,
  onClick,
  variant = "primary",
  disabled = false,
}) => {
  return (
    <button onClick={onClick} disabled={disabled} className={variant}>
      {label}
    </button>
  );
};

// Alternative (Recommended for better type inference)
function Button({ label, onClick, variant = "primary" }: ButtonProps) {
  return <button onClick={onClick}>{label}</button>;
}
```

### **2. Typing useState**

```typescript
// Simple state
const [count, setCount] = useState<number>(0);
const [name, setName] = useState<string>("");
const [isOpen, setIsOpen] = useState<boolean>(false);

// Object state
interface User {
  id: number;
  name: string;
  email: string;
}

const [user, setUser] = useState<User | null>(null);

// Array state
const [items, setItems] = useState<string[]>([]);
const [users, setUsers] = useState<User[]>([]);
```

### **3. Typing Events**

```typescript
// Common event types
const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
  console.log(e.currentTarget);
};

const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  setName(e.target.value);
};

const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
};

const handleKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
  if (e.key === "Enter") {
    // Do something
  }
};
```

### **4. Typing useRef**

```typescript
// DOM ref
const inputRef = useRef<HTMLInputElement>(null);

// Value ref
const timerRef = useRef<number | null>(null);

// Usage
useEffect(() => {
  inputRef.current?.focus();
}, []);
```

### **5. Typing useEffect & Custom Hooks**

```typescript
// useEffect (no typing needed, but return type matters)
useEffect(() => {
  // Cleanup function
  return () => {
    console.log("cleanup");
  };
}, [dependencies]);

// Custom Hook
function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    const saved = localStorage.getItem(key);
    return saved ? JSON.parse(saved) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue] as const;
}

// Usage
const [user, setUser] = useLocalStorage<User>("user", null);
```

### **6. Typing Context**

```typescript
interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within AuthProvider");
  }
  return context;
};
```

### **7. Typing API Calls & Async Functions**

```typescript
interface ApiResponse<T> {
  data: T;
  error?: string;
  status: number;
}

interface Product {
  id: number;
  name: string;
  price: number;
}

async function fetchProducts(): Promise<Product[]> {
  const response = await fetch("/api/products");
  const data: ApiResponse<Product[]> = await response.json();
  return data.data;
}

// With React Query
const { data, isLoading } = useQuery<Product[], Error>({
  queryKey: ["products"],
  queryFn: fetchProducts,
});
```

### **8. Typing Forms with React Hook Form**

```typescript
import { useForm } from "react-hook-form";

interface FormData {
  email: string;
  password: string;
  age: number;
}

function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<FormData>();

  const onSubmit = (data: FormData) => {
    console.log(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register("email")} type="email" />
      <input {...register("password")} type="password" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

---

## üîß **Common TypeScript + React Patterns**

### **Children Props**

```typescript
interface CardProps {
  title: string;
  children: React.ReactNode; // Can be anything renderable
}

// Or more specific
interface CardProps {
  title: string;
  children: React.ReactElement; // Must be a React element
  // children: JSX.Element; // Same as ReactElement
  // children: React.ReactNode[]; // Array of nodes
}
```

### **Component with Generic Props**

```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return <div>{items.map(renderItem)}</div>;
}

// Usage
<List<User> items={users} renderItem={(user) => <div>{user.name}</div>} />;
```

### **Typing Router (React Router)**

```typescript
import { useParams, useNavigate } from "react-router-dom";

interface RouteParams {
  id: string;
  agentId: string;
}

function AgentDetail() {
  const { agentId } = useParams<RouteParams>();
  const navigate = useNavigate();

  // agentId is string | undefined
  if (!agentId) return <div>Not found</div>;

  return <div>Agent {agentId}</div>;
}
```

---

## üé® **Best Practices for React + TypeScript**

### **1. Always Define Props Interfaces**

```typescript
// ‚ùå Bad
function Button(props: any) { ... }

// ‚úÖ Good
interface ButtonProps {
  label: string;
  onClick: () => void;
}
function Button({ label, onClick }: ButtonProps) { ... }
```

### **2. Use Type Inference When Possible**

```typescript
// ‚ùå Unnecessary
const [count, setCount] = useState<number>(0);

// ‚úÖ Better (TypeScript infers number)
const [count, setCount] = useState(0);

// ‚úÖ Only when needed
const [user, setUser] = useState<User | null>(null);
```

### **3. Avoid `any`, Use `unknown` Instead**

```typescript
// ‚ùå Bad
const data: any = await fetch();

// ‚úÖ Better
const data: unknown = await fetch();
if (typeof data === "object" && data !== null) {
  // Type guard
}
```

### **4. Create Shared Type Files**

```typescript
// types/user.ts
export interface User {
  id: number;
  name: string;
  email: string;
}

// types/api.ts
export interface ApiResponse<T> {
  data: T;
  error?: string;
}

// Import everywhere
import { User } from "@/types/user";
```

---

## üö® **Common Errors & Solutions**

### **Error 1: "Type 'null' is not assignable to type 'X'"**

```typescript
// ‚ùå Problem
const [user, setUser] = useState<User>(null); // Error!

// ‚úÖ Solution
const [user, setUser] = useState<User | null>(null);
```

### **Error 2: "Object is possibly 'null'"**

```typescript
// ‚ùå Problem
inputRef.current.focus(); // Error!

// ‚úÖ Solution
inputRef.current?.focus(); // Optional chaining
// OR
if (inputRef.current) {
  inputRef.current.focus();
}
```

### **Error 3: "Property does not exist on type"**

```typescript
// ‚ùå Problem
const handleChange = (e) => {
  // e is 'any'
  console.log(e.target.value);
};

// ‚úÖ Solution
const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  console.log(e.target.value);
};
```

---

## üì¶ **Project Structure for TypeScript React**

```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Card.tsx
‚îÇ   ‚îî‚îÄ‚îÄ common/
‚îÇ       ‚îî‚îÄ‚îÄ Header.tsx
‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ Home.tsx
‚îÇ   ‚îî‚îÄ‚îÄ About.tsx
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ user.ts
‚îÇ   ‚îú‚îÄ‚îÄ api.ts
‚îÇ   ‚îî‚îÄ‚îÄ index.ts (re-exports all)
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îî‚îÄ‚îÄ useFetch.ts
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ api.ts
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ helpers.ts
‚îî‚îÄ‚îÄ App.tsx
```

---

## üí° **Quick Reference - Most Used Types**

```typescript
// Component Props
type Props = {
  title: string;
  count?: number; // Optional
  onClick: () => void;
  children: React.ReactNode;
};

// State
useState<User | null>(null);
useState<string[]>([]);

// Refs
useRef<HTMLDivElement>(null);
useRef<HTMLInputElement>(null);

// Events
React.MouseEvent<HTMLButtonElement>;
React.ChangeEvent<HTMLInputElement>;
React.FormEvent<HTMLFormElement>;
React.KeyboardEvent<HTMLInputElement>;

// Async/API
Promise<User>;
Promise<void>;
async (): Promise<Data> => {};
```

---

## üéì **Real Project Example**

```typescript
// types/agent.ts
export interface Agent {
  id: string;
  name: string;
  status: "active" | "inactive";
  createdAt: Date;
}

// components/AgentCard.tsx
import { Agent } from "@/types/agent";

interface AgentCardProps {
  agent: Agent;
  onEdit: (id: string) => void;
  onDelete: (id: string) => void;
}

export function AgentCard({ agent, onEdit, onDelete }: AgentCardProps) {
  return (
    <div className="border rounded-lg p-4">
      <h3>{agent.name}</h3>
      <span
        className={
          agent.status === "active" ? "text-green-500" : "text-gray-500"
        }
      >
        {agent.status}
      </span>
      <button onClick={() => onEdit(agent.id)}>Edit</button>
      <button onClick={() => onDelete(agent.id)}>Delete</button>
    </div>
  );
}

// pages/AgentList.tsx
import { useState, useEffect } from "react";
import { AgentCard } from "@/components/AgentCard";
import { Agent } from "@/types/agent";

export function AgentList() {
  const [agents, setAgents] = useState<Agent[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    fetchAgents();
  }, []);

  const fetchAgents = async () => {
    try {
      const response = await fetch("/api/agents");
      const data: Agent[] = await response.json();
      setAgents(data);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  const handleEdit = (id: string) => {
    console.log("Edit agent:", id);
  };

  const handleDelete = (id: string) => {
    setAgents(agents.filter((a) => a.id !== id));
  };

  if (loading) return <div>Loading...</div>;

  return (
    <div className="grid grid-cols-3 gap-4">
      {agents.map((agent) => (
        <AgentCard
          key={agent.id}
          agent={agent}
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
}
```

---

## ‚ö° **Pro Tips for Production**

1. **Always export types** - Other files might need them
2. **Use strict mode** in tsconfig.json
3. **Create a types folder** for shared interfaces
4. **Use React.FC sparingly** - Direct function typing is better
5. **Leverage VS Code IntelliSense** - Hover over variables to see types
6. **Use TypeScript with Tailwind** - Install `@types/tailwindcss`
7. **Type your API responses** - Prevents runtime errors
8. **Use Zod or Yup** for runtime validation

---

## üîó **Essential Resources**

- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [React + TypeScript Best Practices](https://www.typescriptlang.org/docs/handbook/react.html)

---

**Now you're ready to work on real React + TypeScript projects! üöÄ**

---

---

# üìö **Table of Contents**

0. [**Video 0 ‚Äì HOW TO Actually Use TypeScript with React**](#-video-0--how-to-actually-use-typescript-with-react) ‚≠ê
1. [Video 1 ‚Äì Introduction to TypeScript](#video-1--introduction-to-typescript)
2. [Video 2 ‚Äì Why Do We Need TypeScript?](#video-2--why-do-we-need-typescript)
3. [Video 3 ‚Äì Basic Types](#video-3--basic-types)
4. [Video 4 ‚Äì Static vs dynamic type checking](#video-4---static-vs-dynamic-type-checking)
5. [Video 5 ‚Äì How to Initialize a TypeScript Project](#video-5-how-to-initialize-a-typescript-project)
6. [Video 6 ‚Äì Using Bundle](#video-6-using-bundle)
7. [Video 7 ‚Äì Understanding tsconfig File](#video-7-understanding-tsconfig-file)
8. [Video 8 ‚Äì Any Type](#video-8--any-type)
9. [Video 9 ‚Äì Object Type in Typescript](#video-9--object-type-in-typeScript)
10. [Video 10 ‚Äì type Keyword and Interfaces in TypeScript](#video-10--type-keyword-and-interfaces-in-typeScript)

11. [Video 11 ‚Äì Defining Functions in TypeScript](#video-11--defining-functions-in-typescript)
12. [Video 12 ‚Äì Void Type Function in TypeScript](#video-12--void-type-function-in-typescript)
13. [Video 13 ‚Äì Optional Parameters in TypeScript](#video-13--optional-parameters-in-typescript)
14. [Video 14 ‚Äì Destructured and Rest Parameters in TypeScript](#video-14--destructured-and-rest-parameters-in-typescript)
15. [Video 15 ‚Äì Typing Variables as Functions](#video-15--typing-variables-as-functions)
16. [Video 16 ‚Äì Unions in TypeScript](#video-16--unions-in-typescript)
17. [Video 17 ‚Äì Intersections in TypeScript](#video-17--intersections-in-typescript)
18. [Video 18 ‚Äì Readonly](#video-18--readonly)
19. [Video 19 ‚Äì keyof Property in TypeScript](#video-19--keyof-property-in-typescript)
20. [Video 20 ‚Äì typeof Modifier in TypeScript](#video-20--typeof-modifier-in-typescript)
21. [Video 21 ‚Äì Index Types in TypeScript](#video-21--index-types-in-typescript)
22. [Video 21.5 ‚Äì Comparison: 'keyof' vs 'typeof' vs Index Types](#comparison--keyof-vs-typeof-vs-index-types)
23. [Video 22 ‚Äì As Const and Enums](#video-22--as-const-and-enums)
24. [Video 23 ‚Äì Tuples in TypeScript](#video-23--tuples-in-typescript)
25. [Video 24 ‚Äì Generics in TypeScript](#video-24--generics-in-typescript)
26. [Video 25 ‚Äì Async Functions & Generics in TypeScript](#video-25--async-functions--generics-in-typescript)
27. [Video 26 ‚Äì Pick and Omit in TypeScript](#video-26--pick-and-omit-in-typescript)
28. [Video 27 ‚Äì Partial and Required in TypeScript](#video-27--partial-and-required-in-typescript)
29. [Video 28 ‚Äì ReturnType and Parameters in TypeScript](#video-28--returntype-and-parameters-in-typescript)
30. [Video 29 ‚Äì Record in TypeScript](#video-29--record-in-typescript)
31. [Video 30 ‚Äì Readonly Type in TypeScript](#video-30--readonly-type-in-typescript)
32. [Video 31 ‚Äì Awaited Utility Type in TypeScript](#video-31--awaited-utility-type-in-typescript)
33. [Video 32 ‚Äì Basic Type Guards](#video-32--basic-type-guards)
34. [Video 33 ‚Äì Never Type](#video-33--never-type)
35. [Video 34 ‚Äì Unknown Type](#video-34--unknown-type)
36. [Video 35 ‚Äì As Casting (Type Assertion)](#video-35--as-casting-type-assertion)
37. [Video 36 ‚Äì Satisfies Keyword](#video-36--satisfies-keyword)
38. [Video 37 ‚Äì Discriminated Union](#video-37--discriminated-union)
39. [Video 38 ‚Äì Function Overloads](#video-38--function-overloads)
40. [Video 39 ‚Äì Type Predicate (User-Defined Type Guards)](#video-39--type-predicate-user-defined-type-guards)
41. [Video 40 ‚Äì Debugging TypeScript](#video-40--debugging-typescript)
42. [Video 41 ‚Äì Importing Types](#video-41--importing-types)
43. [Video 42 ‚Äì Declaration Files](#video-42--declaration-files)
44. [Last Video ‚Äì Classes in TypeScript](#last-video--classes-in-typescript)

---

# Video 1 ‚Äì Introduction to TypeScript

<a id="video-1--introduction-to-typescript"></a>

There is a **TypeScript configuration file** (`tsconfig.json`).

---

### Example Code

```ts
const button = document.createElement("button");
button.addEventListener("click", handleClick);

function handleClick(e: MouseEvent) {
  console.log(e.target);
}
```

---

# Video 2 ‚Äì Why Do We Need TypeScript?

1. **Type Safety (Incorrect arguments/order issue)**

   - In JavaScript, you can pass arguments in the wrong order or even with the wrong type, and it won‚Äôt complain until runtime.

   - Example:

     ```js
     function add(a, b) {
       return a + b;
     }
     add("5", 10); // Works, but result = "510"
     ```

   - With TypeScript, you define parameter types, so errors are caught at **compile time**, not runtime.

     ```ts
     function add(a: number, b: number): number {
       return a + b;
     }
     add("5", 10); // ‚ùå Error at compile time
     ```

2. **Early Error Detection (Compile-time checks)**

   - JavaScript is an **interpreted language**: it executes line by line, and you only see errors when the code runs.
   - TypeScript introduces a **compilation stage**, where the TypeScript compiler (`tsc`) checks your code for type errors before execution.
   - This saves time because you don‚Äôt have to wait until runtime to discover mistakes.

3. **Better Developer Experience**

   - Auto-completion, IntelliSense, and code navigation in editors become much more powerful with TypeScript.
   - This reduces bugs and improves productivity.

4. **Maintainability in Large Codebases**

   - As projects grow, keeping track of types in plain JavaScript gets hard.
   - TypeScript enforces contracts between different parts of your code, making it easier for teams to collaborate without breaking things.

---

‚úÖ **So in short:**
We need TypeScript because it introduces a **compilation stage** to JavaScript, where type-related errors are caught early. This prevents runtime issues, enforces type safety, improves code maintainability, and gives a better developer experience.

### Note :---- The typescript compiler (tsc) is used to compile Typescript code into Javascript Code that can be executed in a Javascript runtime.

## 2) What TypeScript actually is?

1. **Superset of JavaScript**

   - All valid JS code is valid TS code.
   - But TS adds new features like static types, interfaces, generics.

2. **Introduces Static Typing**

   - Lets us define types at compile time.
   - Example:

     ```ts
     let age: number = 25;
     age = "twenty"; // ‚ùå Error
     ```

3. **Transpiles to JavaScript**

   - Browsers/Node don‚Äôt understand TS.
   - `tsc` compiler converts `.ts` ‚Üí `.js`.

4. **Better Developer Tooling**

   - IntelliSense, autocompletion, and refactoring become more powerful.

---

‚úÖ **So in short:**
TypeScript is a syntatic **superset of JavaScript (it has everything that js have)** that adds **static typing + compile-time error checking**which allows developer to add types , and after the compilation is done it is converted into JavaScript code for execution.

---

# Video 3 ‚Äì Basic Types

## --- Basic Types in TypeScript ---

1. **number**

   ```ts
   let age: number = 25;
   ```

2. **string**

   ```ts
   let name: string = "Vipul";
   ```

3. **boolean**

   ```ts
   let isActive: boolean = true;
   ```

4. **any**

   ```ts
   let data: any = 42;
   data = "hello"; // works
   ```

5. **null / undefined**

   ```ts
   let n: null = null;
   let u: undefined = undefined;
   ```

6. **array** (for eg array of numbers)

   ```ts
   let arr: number[] = [1, 2, 3];
   ```

7. **tuple**

   ```ts
   let person: [string, number] = ["Alice", 25];
   ```

8. **enum**

   ```ts
   enum Direction {
     Up,
     Down,
     Left,
     Right,
   }
   let move: Direction = Direction.Up;
   ```

9. **object**

   ```ts
   let user: {
     name: string;
     age: number;
     showSummary: () => void; // jab kuch return nahi krna ho tb void return type
     showAge: (id: number) => number; // jab kuch return ho toh wo  type return kr do
   } = {
     name: "Bob",
     age: 20,
     showSummary() {
       console.log("Shashwat");
     },
     showAge(id: number) {
       return id + this.age; // just an example logic
     },
   };
   ```

10. **union**

```ts
let id: number | string;
id = 101;
id = "abc";
```

11. **Function**

Note :--- WE DONOT NEED TO DEFINE THE RETURN TYPE IT IS RECOMMENDED NOT to do it.....

### Full Function Type Example

```ts
// Function type declaration
type AddFn = (a: number, b: number) => number;

// Below we are seeing three number (two of them are for parameter and the last number is the return type of that function)

// Function implementation using that type
const add: AddFn = (x: number, y: number): number => {
  return x + y;
};

console.log(add(5, 10)); // 15
```

---

### Inline Function Type (without type alias)

```ts
const multiply: (a: number, b: number) => number = (a, b) => {
  return a * b;
};

console.log(multiply(3, 4)); // 12
```

#### Type Annotating a Function

1. **Annotating Parameters**

   ```ts
   function add(a: number, b: number) {
     return a + b;
   }
   ```

2. **Annotating Return Type**

   ```ts
   function add(a: number, b: number): number {
     return a + b;
   }
   ```

3. **Void Functions**

   ```ts
   function greet(name: string): void {
     console.log("Hello " + name);
   }
   ```

4. **Union Parameters**

   ```ts
   function printId(id: number | string): void {
     console.log("ID: " + id);
   }
   ```

   ‚úÖ **Pattern to remember for interview:**

```
(param1: type, param2: type, ...) => returnType
```

Example:

- `(a: number, b: number) => number` ‚Üí returns number
- `(msg: string) => void` ‚Üí returns nothing
- `() => boolean` ‚Üí no params, returns boolean

‚úÖ **So in short:**
TS has all JS primitive types plus extra ones like **tuple, enum, union** for safer coding.

---

null vs undefined ...

const a :null = undefined ‚ùåthis is wrong null and undefined are not same

---

# Video 4 - Static vs dynamic type checking

## static vs dynamic type checking

1. **Dynamic Typing (can be reasssigned to anything no to string to boolean)(JavaScript)**

   - Errors appear at runtime.
   - Example:

     ```js
     let x = 5;
     x = "hello"; // allowed
     ```

2. **Static Typing (TypeScript)**

   - Errors are caught at compile time.
   - Example:

     ```ts
     let x: number = 5;
     x = "hello"; // ‚ùå error
     ```

3. **Key Difference**

   - JS = dynamic ‚Üí flexible but unsafe.
   - TS = static ‚Üí strict but safer.

---

‚úÖ **So in short:**
JavaScript checks types at **runtime**, while TypeScript checks at **compile time**.

---

# Video 5 ‚Äì How to Initialize a TypeScript Project

## 2. How to Intiliaze a typescript projct ??

### Way 1:- - Doing manually using typescript command line tool ...

STep1:--- create a proj with npm

`npm init -y`
(-y gives default value of package.jsonn)

Step 2:-- Installl typescript compiler (as a dev depenedency )

crate a script.ts file ( any typescript file to run codes)

step 3:-- In order to get tsconfig.js( to get errors )

`npx tsc --init`

(this line initilaize config file)

step 4:-- How to compile this file

`npx tsc sript.ts` (script.ts is name of the file)

Note - the step 4 takes typescript file and convert it to js ..

note (step 5) :--- if we dont want to change the js file on error we can run this instead of step 4

`npx tsc script. ts --noEmitOnError` (it will not change the js file until we solve the error in the typescript file)

---

Now create function and tell all the parameters types

```ts
const numl = -1;
const num2 = 3;

function sum(a: number, b: number) {
  return a + b;
}
```

---

# Video 6 ‚Äì Using Bundle

### Way2:---- using a bundle ... (vite)

Step 1:--- (same react insall bs whaa typescript bs select kr lo ho gya )

---

# Video 7 ‚Äì Understanding tsconfig File

## Understand the typescript.config file :--- tsconfig.json)

```ts

{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

```

---

# Video 7:--- (see Basic types only)

## Array types(see both notes and put them here (18 and 19.1 i mean)

See above only Basic Types :----

---

# Video 8 ‚Äì Any Type

The `any` type in TypeScript basically **turns off type checking**.
It‚Äôs like writing plain JavaScript inside TypeScript.

---

## 1) Example of `any`

```ts
let a: any = 4;
a = "hello"; // ‚úÖ Allowed
a = true; // ‚úÖ Allowed
```

üëâ `any` accepts **any value** and disables TypeScript‚Äôs safety.
This removes the whole point of using TypeScript.

---

## 2) Why Not Use `any`?

- No type safety (you lose autocomplete & error detection).
- Can cause runtime bugs that TypeScript is supposed to prevent.
- Basically turns TypeScript ‚Üí JavaScript.

That‚Äôs why it‚Äôs considered **bad practice**.

---

## 3) Where Does `any` Appear?

Sometimes `any` comes in **automatically**, even if you don‚Äôt write it.

### Example: `JSON.parse`

```ts
const data = JSON.parse('{"name":"Kyle"}');
// data is type: any
```

üëâ Because JSON can return _anything_, TypeScript infers `any`.

### Example: API calls

```ts
async function fetchData() {
  const res = await fetch("https://api.example.com");
  const data = await res.json(); // type: any
  return data;
}
```

Here `data` is `any` because the API can return **any shape of JSON**.

---

## 4) How to Avoid `any`

Instead of letting values become `any`, define a type or interface.

```ts
type Person = {
  name: string;
  age: number;
};

const data: Person = JSON.parse('{"name":"Kyle","age":28}');
console.log(data.name); // ‚úÖ Safe with autocomplete
```

Or with API:

```ts
type User = {
  id: number;
  username: string;
};

async function fetchUser(): Promise<User> {
  const res = await fetch("/api/user");
  const data: User = await res.json();
  return data;
}
```

‚úÖ Now TypeScript ensures the correct structure.

---

## ‚úÖ Summary

- `any` disables TypeScript‚Äôs type safety (avoid it).
- It often sneaks in from **`JSON.parse`** or **API responses**.
- Prefer defining **types** or **interfaces** instead.
- If you‚Äôre unsure of the type, use **`unknown`** (safer) instead of `any`.

---

# Video 9 ‚Äì Object Type in TypeScript

Objects are one of the most important types in TypeScript.
They allow us to **group related properties together** with type safety.

---

## 1) Basic Object Type

We can define the shape of an object by explicitly listing its properties.

```ts
const person: { name: string; age: number } = {
  name: "Kyle",
  age: 28,
};
```

üëâ Here `person` must always have both `name` (string) and `age` (number).

---

## 2) Problem ‚Äì Adding Extra Properties Later

If we try to **add a new property later** that wasn‚Äôt defined, TypeScript will throw an error.

```ts
const person: { name: string; age: number } = {
  name: "Kyle",
  age: 28,
};

person.isProgrammer = true; // ‚ùå Error: Property 'isProgrammer' does not exist
```

---

## 3) Solution ‚Äì Optional Properties

If some properties may or may not exist, we mark them with **`?` (optional property)**.

```ts
const person: { name: string; age: number; isProgrammer?: boolean } = {
  name: "Kyle",
  age: 28,
};

console.log(person.isProgrammer); // ‚úÖ allowed (might be undefined)
```

üëâ `isProgrammer` can be either `true`, `false`, or **not present at all**.

---

## 4) Syntax Variations

When defining object types inline, we can use:

- **Comma ( , )**
- **Semicolon ( ; )**
- **Newline**

All are valid separators.

```ts
const person: {
  name: string;
  age: number;
  isProgrammer?: boolean;
} = {
  name: "Kyle",
  age: 28,
};
```

‚úÖ This is just formatting preference.

---

## ‚úÖ Summary

- Objects in TS must strictly follow their type definition.
- Adding extra properties not defined ‚Üí **Error**.
- Use **optional properties (`?`)** for flexibility.
- Inline object type definitions can use `,`, `;`, or newline separators.

---

# Video 10 ‚Äì Type Keyword and Interfaces in TypeScript

---

## 1. üîπ Inline Types

üëâ You can directly define the type of an object inline:

```ts
const person: { name: string; age: number; isProgrammer?: boolean } = {
  name: "Kyle",
  age: 28,
};
```

- `name: string` ‚Üí required property
- `age: number` ‚Üí required property
- `isProgrammer?: boolean` ‚Üí optional property (`?` means optional)

---

## 2. üîπ Extracting Types with `type` Keyword

üëâ Instead of repeating the inline type everywhere, we can **extract it into a reusable type alias** using the `type` keyword.

So we will need to define a type and in order to do that we use "type" keyword and for all the type name it will be in camelcase and we always use first Letter as capital (unlike js where first letter is small)

```ts
type PersonName = {
  name: string;
  age: number;
  isProgrammer?: boolean;
  friends: string[];
  address: {
    street: string;
  };
};

const person: PersonName = {
  name: "Kyle",
  age: 28,
  friends: ["Sam", "John"],
  address: {
    street: "Main St.",
  },
};
```

---

## 3. üîπ Notes on `type` Keyword

- By convention ‚Üí **type names start with a capital letter** (PascalCase).
- `type` is not limited to objects ‚Üí it can represent **any type**.

```ts
type Age = number;

const myAge: Age = 28; // same as writing `const myAge: number`
```

---

## 4. üîπ Interfaces in TypeScript

üëâ Interfaces are almost identical to type aliases when working with **objects**, but with a slightly different syntax.

### ‚úÖ Example with `interface`

```ts
interface Person {
  name: string;
  age: number;
  isProgrammer?: boolean;
  friends: string[];
  address: {
    street: string;
  };
}
```

üëâ Using it:

```ts
const person: Person = {
  name: "Kyle",
  age: 28,
  friends: ["Sam", "John"],
  address: {
    street: "Main St.",
  },
};
```

---

## 5. üîπ Syntax Difference

- `type` uses `=` assignment

```ts
type Person = { name: string; age: number };
```

- while `interface` does **not** use `=` and can only b used with object .Except the above difference in defining the interface there is no mazor difference when we are using it ...

```ts
interface Person {
  name: string;
  age: number;
}
```

---

## 6. üîπ Difference between `type` and `interface`

| Feature                 | `type`                                | `interface`                                |
| ----------------------- | ------------------------------------- | ------------------------------------------ |
| **Objects**             | ‚úÖ Yes                                | ‚úÖ Yes                                     |
| **Primitives**          | ‚úÖ Yes (can alias `number`, `string`) | ‚ùå No (objects only)                       |
| **Unions**              | ‚úÖ Yes (`type A = B \| C`)            | ‚ùå Not supported directly                  |
| **Extending**           | ‚úÖ Can use intersections (`&`)        | ‚úÖ Can `extends` another interface         |
| **Declaration Merging** | ‚ùå Not supported                      | ‚úÖ Supported (merge same-named interfaces) |
| **Syntax**              | Uses `=` assignment                   | No `=` sign                                |

---

## üéØ Quick Summary

1. Use **`type` keyword** for:

   - Objects
   - Primitives
   - Union / Intersection types

2. Use **`interface`** for:

   - Objects only
   - When you need **extends** or **declaration merging**

3. Both are very similar when working with objects.

---

---

# Video 11 ‚Äì Defining Functions in TypeScript

See above basic typ and their see the functon ....
Note :--- WE DONOT NEED TO DEFINE THE RETURN TYPE IT IS RECOMMENDED NOT to do it.....

---

## 1. üîπ Basic Function with Type Alias

üëâ We can define a **type** for objects and then use it in function parameters.

```ts
type Person = { name: string };

function printPerson(person: Person) {
  console.log(person.name);
}

printPerson({ name: "Kyle" });
```

- `type Person = { name: string }` ‚Üí type alias for the object.
- `person: Person` ‚Üí function parameter uses that type.
- Function just logs the name.

---

## 2. üîπ Inline Type Annotation (without alias)

üëâ We can also directly write the type in the parameter.

```ts
function printPerson(person: { name: string }) {
  console.log(person.name);
}

printPerson({ name: "Kyle" });
```

- This avoids creating a separate type alias.
- But using `type` makes code more reusable and cleaner.

---

## 3. üîπ Extra Properties Case

TypeScript is **strict with inline objects**.
If you pass an object literal with extra properties ‚Üí it shows an error.

```ts
function printPerson(person: Person) {
  console.log(person.name);
}

printPerson({ name: "Kyle", age: 28 });
// ‚ùå Error: Object literal may only specify known properties
```

---

## 4. üîπ Workaround: Assign to a Variable First

üëâ If you assign the object to a variable first, then pass it ‚Üí **no error**, because TypeScript allows extra properties in that case.

```ts
function printPerson(person: Person) {
  console.log(person.name);
}

const person = { name: "Kyle", age: 28 };
printPerson(person); // ‚úÖ Works fine
```

- Here, `person` has `name` and `age`.
- Function only cares about `name`, so no issue.

---

## 5. üîé Return Types

By default, TypeScript can **infer** the return type.
It‚Äôs recommended **not to explicitly define return type** unless needed.

```ts
function printPerson(person: Person) {
  console.log(person.name);
}
// inferred return type = void
```

---

## üéØ Quick Summary

1. Functions can use **type aliases** for clean code.
2. Or define types **inline** in parameters.
3. Passing **extra properties directly** ‚Üí error.
4. Assigning to a variable first ‚Üí works (because TS checks shape compatibility, not exact object literal).
5. Return type usually **inferred automatically** (recommended not to write explicitly unless necessary).

---

---

# Video 12 ‚Äì Void Type Function in TypeScript

---

## 1. üîπ What is a `void` type?

üëâ In TypeScript, if a function **does not return any value**, its return type is `void`.
This is different from a function that **returns `undefined` explicitly**.

---

## 2. ‚úÖ Example

```ts
function printName(name: string): void {
  console.log(name);
}
```

or

```ts
function printName(name: string) {
  console.log(name);
}
```

- `: void` ‚Üí function return type is `void`.
- It just logs the value and does not return anything.

---

## 3. üîé Difference: `void` vs `undefined`

```ts
function doNothing(): void {
  // does nothing, returns nothing
}

function returnUndefined(): undefined {
  return undefined; // explicitly returns undefined
}
```

- `void` ‚Üí means ‚Äúno return value at all‚Äù.
- `undefined` ‚Üí means function actually returns `undefined` explicitly.

---

## 4. ‚ö° JavaScript Comparison

In JavaScript, if a function doesn‚Äôt return anything, it automatically returns `undefined`.
But TypeScript differentiates between:

- **No return value** ‚Üí `void`
- **Explicitly returning undefined** ‚Üí `undefined` type

---

## üéØ Quick Summary

1. Use `void` when a function doesn‚Äôt return anything.
2. `void` ‚â† `undefined` (they are different types).
3. In JS, absence of return = `undefined`, but in TS we **type it as `void`**.

---

---

# Video 13 ‚Äì Optional Parameters in TypeScript

---

## 1. üîπ What is an Optional Parameter?

üëâ In TypeScript, if you want a function parameter to be **optional**, you just add a **question mark (`?`)** after the parameter name.
This means:

- Caller may **pass it** or
- **Skip it** (undefined by default).

---

## 2. ‚úÖ Example

```ts
function printNameAndAge(name: string, options?: { debugMode: boolean }) {
  console.log(name, options);
}

printNameAndAge("Vipul");
// Output: Vipul undefined

printNameAndAge("Vipul", { debugMode: true });
// Output: Vipul { debugMode: true }
```

---

## 3. üîé How it Works

- `options?` ‚Üí tells TypeScript this parameter is **not required**.
- If the argument is not provided ‚Üí it becomes `undefined`.
- If provided ‚Üí must match the given type (`{ debugMode: boolean }` in this case).

---

## 4. ‚ö° JavaScript Comparison

üëâ In JavaScript, everything is optional by default, but we don‚Äôt have type checking.

```js
function printNameAndAge(name, options) {
  console.log(name, options);
}

printNameAndAge("Vipul"); // Vipul undefined
```

üîë In JS you won‚Äôt get any error, but in TS you get **type safety**.

---

## üéØ Quick Summary

1. Add `?` after parameter name ‚Üí makes it optional.
2. If skipped ‚Üí becomes `undefined`.
3. If passed ‚Üí must follow the type.
4. Difference with JS:

   - JS allows anything (unsafe).
   - TS ensures type safety.

---

# Video 14 ‚Äì Destructured and Rest Parameters in TypeScript

---

## 1. üîπ Destructured Parameters

üëâ Normally, when a function takes an object, we can **destructure** properties directly in the parameter list.

### ‚úÖ JavaScript way

```js
function greet({ name, age }) {
  console.log(`Hello ${name}, you are ${age}`);
}

greet({ name: "Vipul", age: 22 }); // Hello Vipul, you are 22
```

### ‚úÖ TypeScript way

```ts
function greet({ name, age }: { name: string; age: number }) {
  console.log(`Hello ${name}, you are ${age}`);
}

greet({ name: "Vipul", age: 22 }); // Hello Vipul, you are 22
```

üîë Difference:

- JS ‚Üí no types
- TS ‚Üí we define types for the destructured object.

---

## 2. üîπ Default Values in Destructured Parameters

üëâ We can also give **default values** to properties during destructuring.

### ‚úÖ JavaScript way

```js
function printNameAndAge(name, { debugMode = false } = {}) {
  console.log(name, debugMode);
}

printNameAndAge("Vipul"); // Vipul false
printNameAndAge("Vipul", { debugMode: true }); // Vipul true
```

### ‚úÖ TypeScript way

```ts
type Option = {
  debugMode?: boolean;
  indentLevel?: number;
};

function printNameAndAge(
  name: string,
  { debugMode = false, indentLevel }: Option = {}
) {
  console.log(name, debugMode, indentLevel);
}

printNameAndAge("Vipul"); // Vipul false undefined
```

üîë Key points:

- `= {}` ‚Üí default empty object, so function won‚Äôt break if no object is passed.
- `debugMode = false` ‚Üí default value used when property is missing.
- `indentLevel` ‚Üí optional, so stays `undefined` if not passed.

---

## 3. üîπ Rest Parameters (`...`)

üëâ Rest parameters allow us to pass **unlimited arguments** which get collected into an array.

### ‚úÖ JavaScript way

```js
function sum(...nums) {
  return nums.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4)); // 10
```

### ‚úÖ TypeScript way

```ts
function sum(...nums: number[]): number {
  return nums.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4)); // 10
```

üîë Difference:

- In TS, we add types (`: number[]`) for the rest array and `: number` for the return type.

---

## 4. üîπ Destructured + Rest Together

üëâ We can also use destructuring with rest parameters:

### ‚úÖ Example

```ts
function logUser({
  name,
  age,
  ...rest
}: {
  name: string;
  age: number;
  [key: string]: any;
}) {
  console.log(name, age, rest);
}

logUser({ name: "Vipul", age: 22, city: "Delhi", country: "India" });
// Output: Vipul 22 { city: "Delhi", country: "India" }
```

---

## 5. üîπ Function Return with Rest

üëâ Using `sum` again, to show return type in TypeScript:

```ts
function sum(...nums: number[]): number {
  return nums.reduce((total, num) => total + num, 0);
}

const total = sum(2, 2, 4);
console.log(total); // 8
```

---

## üéØ Quick Summary

1. **Destructured Parameters**

   - JS: simple destructuring.
   - TS: same but with type annotations.

2. **Default Values**

   - Can give defaults while destructuring.
   - Default empty object `{}` avoids errors when no arg passed.

3. **Rest Parameters**

   - Collect multiple args into an array using `...`.
   - TS requires type annotations for rest array.

4. **Return Type**

   - TS allows explicit return types for safety.

---

üëâ So bhai, destructuring helps unpack properties easily, and rest helps collect unlimited arguments.
Together with default values + TypeScript types, code becomes **safer and more readable**.

---

# Video 15 ‚Äì Typing Variables as Functions

## 1) Functions in JavaScript (as values)

In JavaScript, functions are just **values**.
They can be stored in variables, passed around, or returned:

```js
function add(a, b) {
  return a + b;
}

let myFunc = add;
console.log(myFunc(2, 3)); // 5
```

‚ö†Ô∏è Problem: No type safety. You can pass wrong arguments and JS won‚Äôt complain until runtime:

```js
console.log(myFunc("hello", "world")); // "helloworld" ‚ùå
console.log(myFunc("hello", 5)); // "hello5" ‚ùå
```

---

## 2) Functions in TypeScript (with types)

TypeScript forces you to define the **shape** of a function (its parameters + return type).

```ts
// Define a function type
type AddFunc = (a: number, b: number) => number;

// Variable with type AddFunc
let myFunc: AddFunc;

// ‚úÖ Correct assignment
myFunc = (x, y) => x + y;

// ‚ùå Wrong assignment
myFunc = (x, y) => "hello";
// Error: Expected number, got string
```

üëâ With TypeScript, mistakes are caught **at compile-time**, not at runtime.

---

## 3) Callbacks in JavaScript vs TypeScript

**JavaScript (unsafe):**

```js
function doSum(a, b, cb) {
  cb(a + b); // cb can be anything
}

doSum(2, 3, (sum) => console.log(sum)); // ‚úÖ works
doSum(2, 3, "not a function"); // ‚ùå runtime crash
```

**TypeScript (safe):**

```ts
function doSum(a: number, b: number, cb: (sum: number) => void) {
  cb(a + b);
}

doSum(2, 3, (sum) => console.log(sum)); // ‚úÖ ok
doSum(2, 3, "hello"); // ‚ùå compile-time error
```

üëâ TypeScript enforces that the callback is really a function, with the correct parameter type.

---

## 4) Why not just use `Function`?

```ts
let x: Function;
```

- ‚ùå This means ‚Äúany function‚Äù ‚Üí no type checking on parameters or return type.
- ‚úÖ Always use **exact signatures** like `(a: number, b: number) => number`.

---

## üîë Key Takeaways

- **JavaScript**: Functions are values, but no safety ‚Üí errors only at runtime.
- **TypeScript**: Functions must match a defined shape `(params: type) => returnType`.
- Great for **callbacks, event handlers, higher-order functions**.
- Use **type aliases** (or interfaces) for clarity.
- Avoid the generic `Function` type.

---

---

# Video 16 ‚Äì **Unions in TypeScript**

In order to handle complex types, we need to understand different ways to **modify** our existing types.

So far, we only know one type of modifier:

- **Optional parameter** inside of our object type.

Now let‚Äôs talk about another important modifier: **Union**.

---

## 1) Union Modifier

Union modifier takes multiple things and says that something is **one of multiple different things**.

---

### ‚ùå Without union (error example)

```ts
let id = 7;
id = "hello"; // ‚ùå Error
```

‚ö° Why?

- TypeScript infers `id` as `number` on first assignment.
- You cannot later reassign it to another type (like `string`).

---

### ‚úÖ With union

```ts
let id: string | number = 7; // now it can be one of two types

id = "7"; // ‚úÖ allowed
id = true; // ‚ùå error (boolean not part of union)
```

Here `|` (pipe) is used (similar to `||` in JS) but for types.

---

## 2) Optional property is actually a union behind the scenes

```ts
type Person = {
  isProgrammer?: boolean;
};

// is same as:
type Person = {
  isProgrammer: boolean | undefined;
};
```

‚ö° That‚Äôs why optional means ‚Üí value can either be the given type or `undefined`.

---

## 3) Literal unions (exact values only)

We can restrict a property to only allow **specific strings** (not _any_ string).

```ts
type Todo = {
  name: string;
  status: "Complete" | "Incomplete" | "Draft";
};

const todo: Todo = {
  name: "Laundry",
  status: "Completed", // ‚ùå Error (typo, not in union)
};
```

‚úÖ TypeScript will even give **autocomplete** for `"Complete" | "Incomplete" | "Draft"`.

---

## 4) Union of object types

We can also create unions of **entire types**.

```ts
type Todo = {
  name: string;
  status: "Complete" | "Incomplete" | "Draft";
};

type Person = {
  name: string;
  age: number;
};

type TodoPerson = Todo | Person;
```

Here `TodoPerson` is either a `Todo` OR a `Person`.

- Note 1: We could have written the union type **inline** instead of using separate `type`s.
- Note 2: We cannot create unions with `interface`. If you need unions, you **must use type**.

---

‚úÖ **Summary**

- Union lets us say: ‚Äúthis can be one of multiple types.‚Äù
- Works with primitives, literals, and object types.
- Optional properties are just a union with `undefined`.
- String literal unions provide **autocomplete + type safety**.
- Use `type` instead of `interface` for unions.

---

---

# Video 17 ‚Äì Intersections in TypeScript

In the last video, we learned about **Union types (`|`)**.

- **Union (`|`)** ‚Üí means a value can be **one type OR another**.

Now we‚Äôll learn about **Intersections (`&`)**, which are basically the **opposite**.

- **Intersection (`&`)** ‚Üí means a value must be **both types at the same time**.

---

## 1) Basic Example of Intersection

```ts
type Person = {
  name: string;
  age: number;
};

type PersonWithId = Person & {
  id: string;
};

const person: PersonWithId = {
  id: "tsdfasd",
  name: "John Doe",
  age: 28,
};
```

‚úÖ Explanation:

- `Person` has `name` and `age`.
- `PersonWithId` = **everything in `Person` + `id`**.
- The final object must satisfy **both types**.

---

## 2) Combining Multiple Types with Intersection

```ts
type Person = {
  name: string;
  age: number;
};

type Todo = {
  complete: boolean;
};

type PersonWithId = Person &
  Todo & {
    id: string;
  };

const person: PersonWithId = {
  id: "tsdfasd",
  name: "Kyle",
  age: 28,
  complete: false, // ‚úÖ now required
};
```

‚úÖ Here `PersonWithId` = `Person` + `Todo` + `{ id: string }`.
So the object must have **all properties**.

---

## 3) Using Interface with Intersection

We can also use intersections with **interfaces**, since interfaces can be combined with `&` just like types.

```ts
interface Person {
  name: string;
  age: number;
}

interface Todo {
  complete: boolean;
}

type PersonWithTodo = Person & Todo;

const person: PersonWithTodo = {
  name: "Alice",
  age: 25,
  complete: true,
};
```

‚úÖ Works exactly the same as `type`.

‚ö° But remember:

- `type` can do both **union** (`|`) and **intersection** (`&`).
- `interface` can only do **intersection**, not union.

---

## 4) Why Union Doesn‚Äôt Work Here ‚ùå

If we tried `Todo | Person`, it would mean:

- The object is **either a Todo OR a Person**, not both.

```ts
type TodoPerson = Todo | Person;

const todo1: TodoPerson = { complete: true }; // ‚úÖ valid
const todo2: TodoPerson = { name: "Kyle", age: 28 }; // ‚úÖ valid
```

‚ùå But if we want something that is **both a Person and a Todo**, union (`|`) won‚Äôt work ‚Üí we must use intersection (`&`).

---

## 5) ‚ö†Ô∏è Important Note about Intersections

If you intersect types with the **same property but different types**, it gives an error:

```ts
type A = { id: string };
type B = { id: number };

type AB = A & B; // ‚ùå Error (conflicting types for `id`)
```

So always avoid overlapping properties with different types.

---

## ‚úÖ Summary

- **Union (`|`)** = ‚Äúone type OR another.‚Äù
- **Intersection (`&`)** = ‚Äúmust satisfy ALL types at once.‚Äù
- Both `type` and `interface` can be intersected.
- Only `type` supports union.
- Be careful of overlapping properties ‚Üí conflicting types cause errors.

---

# Video 18 ‚Äì Readonly

Sometimes we want to **prevent modification** of a property or a data structure.

---

## 1) Normal Behavior (modifiable)

By default, all properties in TypeScript are writable.

```ts
type Person = {
  id: number;
  name: string;
  age: number;
};

const person: Person = {
  id: 1,
  name: "Kyle",
  age: 28,
};

person.id = 2; // ‚úÖ Allowed (but maybe not what we want)
```

Here `id` can be changed, even though usually an `id` should stay fixed.

---

## 2) Making a Property Readonly

To make a property **immutable**, we add the `readonly` keyword before it.

```ts
type Person = {
  readonly id: number;
  name: string;
  age: number;
};

const person: Person = {
  id: 1,
  name: "Kyle",
  age: 28,
};

person.id = 2; // ‚ùå Error: Cannot assign to 'id' because it is a read-only property
```

‚úÖ Now `id` cannot be changed after initialization.

---

## 3) Readonly with Arrays

Readonly can also be applied to arrays.

```ts
type NumberArray = readonly number[];

const nums: NumberArray = [1, 2, 3];

nums.push(4); // ‚ùå Error
nums[0] = 10; // ‚ùå Error
```

‚úÖ Reading is still allowed:

```ts
console.log(nums[0]); // works fine
```

---

## 4) Readonly Utility Type (All Properties at Once)

Instead of writing `readonly` before each property, we can use TypeScript‚Äôs built-in `Readonly<T>` utility type.

```ts
type Person = {
  id: number;
  name: string;
  age: number;
};

// Make all properties readonly
type ReadonlyPerson = Readonly<Person>;

const person: ReadonlyPerson = {
  id: 1,
  name: "Kyle",
  age: 28,
};

person.age = 30; // ‚ùå Error: Cannot assign to 'age'
```

‚úÖ This automatically marks **all properties as readonly**.

---

## 5) ReadonlyArray<T> (Utility Type for Arrays)

TypeScript also provides a utility type for arrays: **`ReadonlyArray<T>`**.
This is similar to using `readonly type[]`, but sometimes preferred for clarity.

```ts
const nums: ReadonlyArray<number> = [1, 2, 3];

nums.push(4); // ‚ùå Error
nums[0] = 10; // ‚ùå Error

console.log(nums[1]); // ‚úÖ Works fine
```

üëâ `readonly number[]` and `ReadonlyArray<number>` are essentially the same.
It‚Äôs mostly about which style you prefer.

---

## 6) Why Use Readonly?

- Prevent accidental changes (e.g., IDs, constants).
- Works with **objects and arrays**.
- Encourages immutability ‚Üí safer and more predictable code.
- `Readonly<T>` saves time when you want **all properties immutable**.
- `ReadonlyArray<T>` is a utility version of `readonly type[]` for arrays.

---

## ‚úÖ Summary

- `readonly` keyword ‚Üí makes a single property or array immutable.
- `readonly type[]` ‚Üí prevents modifying arrays.
- `Readonly<T>` ‚Üí marks **all properties in a type** as readonly.
- `ReadonlyArray<T>` ‚Üí utility type for arrays (same as `readonly type[]`).
- Still allows **reading**, just not **changing**.

---

Nice one üëç This **`keyof`** concept is very important in TypeScript ‚Äî it makes your code **safer and more dynamic**. Let me expand your **Video 19 notes** properly.

---

# Video 19 ‚Äì `keyof` Property in TypeScript

The `keyof` operator lets us **extract the keys of a type as a union of string literals**.
It‚Äôs useful when we want to restrict values to only the **existing keys of a type**, so we don‚Äôt pass unknown/invalid keys.

---

## 1) Problem Without `keyof`

If we don‚Äôt specify, TypeScript allows **any string** for `key`, which is unsafe.

```ts
type Person = {
  name: string;
  age: number;
};

// ‚ùå No restriction on `key`
function getValue(key: string, person: Person) {
  return person[key as keyof Person]; // forced type assertion
}

const person = { name: "Kyle", age: 28 };

getValue("name", person); // works
getValue("age", person); // works
getValue("random", person); // ‚ùå Allowed at compile time, fails at runtime
```

Here `"random"` doesn‚Äôt exist in `Person`, but TypeScript doesn‚Äôt stop us.
This could cause **bugs at runtime**.

---

## 2) Solution: Using `keyof`

When we use `keyof Person`, the function only accepts `"name"` or `"age"`.

```ts
type Person = {
  name: string;
  age: number;
};

function getValue(key: keyof Person, person: Person) {
  return person[key];
}

const person = { name: "Kyle", age: 28 };

const age = getValue("age", person); // ‚úÖ Safe
const name = getValue("name", person); // ‚úÖ Safe

getValue("random", person); // ‚ùå Error: Argument of type '"random"' is not assignable
```

‚úÖ Now TypeScript protects us ‚Äî only **valid keys** of `Person` can be used.

---

## 3) Why is `keyof` Needed? (Real World Example)

Imagine we‚Äôre building a **generic data lookup function**. Without `keyof`, we could accidentally use invalid keys.

Example: Database model

```ts
type User = {
  id: number;
  username: string;
  email: string;
  isAdmin: boolean;
};

function getUserValue(user: User, key: keyof User) {
  return user[key];
}

const user: User = {
  id: 1,
  username: "vipulraj",
  email: "vipul@example.com",
  isAdmin: false,
};

// ‚úÖ Only valid keys allowed
console.log(getUserValue(user, "id")); // 1
console.log(getUserValue(user, "username")); // "vipulraj"

// ‚ùå Invalid keys rejected
// console.log(getUserValue(user, "password")) // Error
```

üëâ With `keyof`, we ensure only **real properties** are accessed, making the code safer and self-documenting.

---

## 4) Advanced: Generic `getValue`

We can make this reusable for **any object** using generics.

```ts
function getValue<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = {
  id: 1,
  username: "vipulraj",
  email: "vipul@example.com",
};

const email = getValue(user, "email"); // type: string
const id = getValue(user, "id"); // type: number
```

‚úÖ Notice TypeScript **knows the exact return type** (`string` for `"email"`, `number` for `"id"`).
This is why `keyof` is very powerful in generic programming.

---

## ‚úÖ Summary

- `keyof Type` ‚Üí gives a **union of property names** of `Type`.
- Helps prevent **invalid keys** at compile time.
- Works great with **objects, generics, and utility functions**.
- Real-world use cases:

  - Safely accessing database fields.
  - Building generic functions (e.g., data mappers, form handlers).
  - Enforcing API contracts.

---

# Video 20 ‚Äì `typeof` Modifier in TypeScript

- **What it is**
- **Why we use it**
- **Where we use it**
- **How we use it**

‚ö° Important: **`typeof` in TypeScript is different from JavaScript‚Äôs `typeof`.**

- **JavaScript `typeof`** ‚Üí used at **runtime** to check the type of a value (e.g., `"string"`, `"number"`).
- **TypeScript `typeof`** ‚Üí used at **compile time** inside **type definitions** to extract the type of a variable or function.

---

## üîπ What it is

- A **TypeScript type operator** that allows you to **capture the type** of an existing variable or function.
- It prevents code duplication by reusing already defined types.
- Unlike JavaScript `typeof`, it **does not give a string**, it gives the actual **TypeScript type**.

---

## üîπ Why we use it

- To **avoid rewriting types** when another variable or function already defines them.
- Ensures that if the original type changes, all dependent variables/types automatically update.
- Useful for **type safety** in arrays, objects, callbacks, and configuration objects.

---

## üîπ Where we use it

1. **Objects** ‚Üí when you want to reuse an object‚Äôs type without defining an interface manually.
2. **Arrays** ‚Üí when you want an array of a specific object type.
3. **Functions** ‚Üí when you want to extract a function‚Äôs type for callbacks, higher-order functions, or utilities.
4. **Config/data objects** ‚Üí when working with strongly-typed constants (e.g., API configs, settings).

---

## üîπ How we use it

### 1) Using `typeof` with Variables

Let‚Äôs say we have an object:

```ts
const person = { name: "Kyle", age: 28, isProgrammer: true };
```

If we want another variable (or an array) to use **exactly the same type** as `person`, instead of rewriting, we can use `typeof`.

```ts
const people: (typeof person)[] = [];

people.push(person); // ‚úÖ Works
people.push({ name: "Sally", age: 24, isProgrammer: false }); // ‚úÖ Works
people.push(2); // ‚ùå Error: number is not assignable to Person type
```

üëâ This way, if `person` changes (e.g., add/remove properties), `people` automatically updates its type.

---

## 2) Using `typeof` with Functions

You can also grab the type of a function.

```ts
function sayHi(name: string) {
  console.log("Hi " + name);
}

// Extract the type of `sayHi`
type FuncType = typeof sayHi;

// Equivalent to: (name: string) => void
const f: FuncType = (name) => console.log("Hello " + name);
```

üëâ This is useful when you want **callbacks or higher-order functions** to match another function‚Äôs type.

---

## 3) Limitations of `typeof` in TypeScript

- You can only use `typeof` on a **variable** or a **function name**.
- You **cannot** use it on function calls or expressions.

‚ùå Invalid:

```ts
type Wrong = typeof sayHi("Kyle") // Error: cannot call function
```

‚úÖ Correct:

```ts
type Correct = typeof sayHi;
```

---

## 4) Real-World Use Cases

1. **Reusing object types** without duplicating code:

   ```ts
   const config = { port: 3000, host: "localhost" };
   type Config = typeof config;
   ```

2. **Strongly typing arrays based on existing objects**:

   ```ts
   const user = { id: 1, name: "Alice" };
   const users: (typeof user)[] = [];
   ```

3. **Typing functions dynamically**:

   ```ts
   function fetchData(url: string): Promise<string> {
     return Promise.resolve("data");
   }

   type FetchFn = typeof fetchData;
   ```

---

## ‚úÖ Summary

- **JS `typeof`** ‚Üí runtime, gives a string like `"string"`, `"number"`.
- **TS `typeof`** ‚Üí compile-time, extracts type of a **variable** or **function**.
- Use it when:

  - You want to **mirror types** of existing objects/functions.
  - Avoid repeating type definitions.

- Cannot be used on **function calls** or complex expressions.

---

## Note -- we cannot do super complex thing with type of we can basically just pass a variable. like we cannot call this sayHi function this will throw an error . we can just pass a function name or a variable.

Perfect üëå Let‚Äôs turn your draft into **clean structured notes** in the same style you prefer (`What it is, Why we use it, Where we use it, How we use it`) ‚Äî this will make **Video 21: Index Types** crystal clear.

---

# Video 21 ‚Äì Index Types in TypeScript

- **What it is**
- **Why we use it**
- **Where we use it**
- **How we use it**

---

## üîπ What it is

- An **index type** allows you to **reference the type of a property** inside another type.
- Syntax is similar to how we access object properties in JavaScript:

```ts
Person["skillLevel"];
```

This means ‚Üí "give me the type of the `skillLevel` property from `Person`."

- Works with both **`type`** and **`interface`**.

---

## üîπ Why we use it

- To **avoid code duplication** when multiple places depend on the same property type.
- Keeps types **linked together** ‚Äî if you change a property in one place, all references update automatically.
- Useful in **generic utilities**, **grouping data**, and **building flexible object shapes**.

---

## üîπ Where we use it

1. **Extracting property types** from objects (`Person["skillLevel"]`).
2. **Defining functions** that accept only valid values from an existing type.
3. **Creating mapped types** (like grouping, filtering, or transforming data).
4. **Extrapolating all property types** from an object or array.

---

## üîπ How we use it

### 1) Avoiding Code Duplication

Without index types, you might duplicate `"Beginner" | "Intermediate" | "Expert"` in multiple places:

```ts
type Person = {
  name: string;
  skillLevel: "Beginner" | "Intermediate" | "Expert" | "Master";
};

function printSkillLevel(
  skillLevel: "Beginner" | "Intermediate" | "Expert" | "Master"
) {
  console.log(skillLevel);
}
```

‚úÖ Using **index types**, we link directly to `Person["skillLevel"]`:

```ts
type Person = {
  name: string;
  skillLevel: "Beginner" | "Intermediate" | "Expert" | "Master";
};

function printSkillLevel(skillLevel: Person["skillLevel"]) {
  console.log(skillLevel);
}
```

Now if we update `Person.skillLevel`, the function automatically updates too.

---

### 2) Grouping Data with Index Types

Imagine grouping people by their skill level.

```ts
type Person = {
  name: string;
  skillLevel: "Beginner" | "Intermediate" | "Expert";
};

type PeopleGroupedBySkillLevel = {
  [index in Person["skillLevel"]]?: Person[];
};

const grouped: PeopleGroupedBySkillLevel = {
  Beginner: [{ name: "Kyle", skillLevel: "Beginner" }],
};
```

üëâ The keys (`Beginner`, `Intermediate`, `Expert`) come directly from `Person["skillLevel"]`.

---

### 3) Extrapolating from Objects

You can also pull out the types of properties dynamically:

```ts
const a = {
  name: "Kyle",
  age: 28,
  isProgrammer: true,
};

type AllProps = (typeof a)[keyof typeof a];
// string | number | boolean

type NameType = (typeof a)["name"];
// string
```

---

## ‚úÖ Summary

- **Index types** let you **reference property types** inside other types (`Person["skillLevel"]`).
- They **prevent duplication** and keep types consistent.
- Commonly used for:

  - Functions tied to property values
  - Grouping and mapping objects
  - Extracting property types

- Syntax is just like **object property access in JS** ‚Äî but at the **type level**.

---

üëâ Do you also want me to prepare a **short ‚ÄúIndex Types vs keyof vs typeof‚Äù comparison chart** (since these 3 are related and often confused)?

Perfect üëç here‚Äôs a **compact comparison chart** for
üëâ **`keyof` vs `typeof` vs Index Types (`T[K]`)**

---

# Comparison - `keyof` vs `typeof` vs Index Types

| Feature           | **`keyof`**                                                          | **`typeof`**                                                                | **Index Types (`T[K]`)**                                         |                |           |
| ----------------- | -------------------------------------------------------------------- | --------------------------------------------------------------------------- | ---------------------------------------------------------------- | -------------- | --------- |
| **What it does**  | Gets all **keys** of a type as a union                               | Extracts the **type of a variable or function**                             | Gets the **type of a specific property** inside another type     |                |           |
| **Output**        | Union of property names (as strings)                                 | The full type of the variable/function                                      | The property‚Äôs type                                              |                |           |
| **Syntax**        | `keyof Person`                                                       | `typeof person`                                                             | `Person["skillLevel"]`                                           |                |           |
| **Example Input** | `ts type Person = { name: string; age: number } `                    | `ts const person = { name: "Kyle", age: 28 } `                              | ```ts type Person = { skillLevel: "Beginner"                     | "Expert" } ``` |           |
| **Result**        | `"name"                                                              | "age"`                                                                      | `{ name: string; age: number }`                                  | `"Beginner"    | "Expert"` |
| **When to use**   | When you want to restrict input to **only property names** of a type | When you want to **reuse an existing variable‚Äôs type** without rewriting it | When you want to **extract property types** to avoid duplication |                |           |

---

## ‚úÖ Quick Examples

### `keyof`

```ts
type Person = { name: string; age: number };
type Keys = keyof Person;
// "name" | "age"
```

### `typeof`

```ts
const person = { name: "Kyle", age: 28 };
type PersonType = typeof person;
// { name: string; age: number }
```

### Index Type (`T[K]`)

```ts
type Person = { skillLevel: "Beginner" | "Expert" };
type Skill = Person["skillLevel"];
// "Beginner" | "Expert"
```

---

üëâ Together, these three (`keyof`, `typeof`, Index Types) form the **foundation of advanced TypeScript typing**.

Do you want me to also make a **single combined example** that shows all three working together in one snippet (so it‚Äôs easier to remember)?

---

Perfect üëç
Main end me ek **comparison table** add kar raha hoon (`const` vs `as const` vs `enum`) taaki ekdum crystal clear ho jaye.

---

# Video 22 ‚Äì As Const and Enums

## üîπ What is `as const`?

- In **TypeScript**, when you define a variable with `let`, it gets a **generic type** (e.g., `number`, `string`) because you can reassign it later.
- When you define a variable with `const`, TypeScript infers a **literal type** (e.g., `1`, `"hello"`). That means the value cannot change.
- Using **`as const`** tells TypeScript to:

  1. Mark the entire value as **readonly**.
  2. Infer **literal types** instead of broad types.

üëâ In short, `as const` is a **compile-time modifier** that freezes the value and makes it more specific.

---

## üîπ Why do we use it?

1. To create **readonly arrays/objects** without writing explicit types.
2. To infer **literal values** instead of general types (helps in unions).
3. To build **enums-like structures** without using actual `enum`.
4. To prevent accidental mutation or reassignment in code.

---

## üîπ How do we use it?

### 1. With Primitives

```ts
let a = 1 as const; // type = 1 (literal), not number
const b = 1; // type = 1
a = true; // ‚ùå Error, cannot reassign
```

‚ö° Note: This usage isn‚Äôt practical because just using `const` already does the job.
üëâ That‚Äôs why `as const` is **not useful for primitives**. It shines more with arrays and objects.

---

### 2. With Arrays

```ts
const nums = ["1", "2", "3"] as const;
// type = readonly ["1", "2", "3"]
```

- Now:

  - The array is **readonly** (no push, no pop, no reassignment).
  - The elements are **literal types** `"1" | "2" | "3"`, not just `string`.

üëâ This is useful when we want to map constant string values (like statuses, categories, etc.).

---

### 3. With Enums-like Structures

Instead of using TypeScript `enum`, we can use `as const` with arrays:

```ts
const SKILL_LEVELS = ["Beginner", "Intermediate", "Expert"] as const;

type Person = {
  skillLevel: (typeof SKILL_LEVELS)[number];
};

// ‚úÖ Valid values: "Beginner" | "Intermediate" | "Expert"
const p1: Person = { skillLevel: "Beginner" };
const p2: Person = { skillLevel: "Expert" };
const p3: Person = { skillLevel: "Master" }; // ‚ùå Error
```

‚úî Benefits:

- Works directly in **JS + TS hybrid projects**.
- Avoids extra complexity of enums.
- Auto-suggest in editors makes it very dev-friendly.

---

### 4. With Objects

```ts
const person = {
  name: "Kyle",
  age: 28,
  address: {
    street: "Main St",
  },
} as const;

person.age = 30; // ‚ùå Error: Readonly
person.address.city = "NY"; // ‚ùå Error: Readonly
```

- Every property (including nested ones) becomes **readonly**.
- All values are inferred as **literals** (e.g., `"Kyle"`, `28`, `"Main St"`) not broad types.

---

## üîπ Where do we use it?

1. **Enums alternative** ‚Üí When you want a fixed set of string/number values.
2. **Readonly arrays/objects** ‚Üí When you don‚Äôt want values to be mutated.
3. **Config/constants** ‚Üí For defining app constants like statuses, roles, categories, etc.
4. **Literal type inference** ‚Üí When you want exact literal types instead of generic ones.

---

## üîπ Nuances (Important Points)

- ‚úÖ Use `const` alone for simple primitives (`const x = 5`).
- ‚úÖ Use `as const` when:

  - You need **literal arrays/objects**.
  - You want **enums-like strictness** without enums.
  - You need **deep readonly** types.

- ‚ùå Don‚Äôt use `as const` unnecessarily with primitives because `const` already narrows them.
- ‚ö° `as const` is **compile-time only** ‚Äî at runtime, it disappears.

---

## ‚úÖ Final Conclusion

`as const` is a **powerful TypeScript feature** that:

- Converts values to **readonly + literal types**.
- Helps in building enums-like structures in a **lightweight way**.
- Prevents accidental mutations.

Think of it as:
üëâ **`const` makes the variable constant, `as const` makes the value deeply constant.**

---

## üîπ Comparison: `const` vs `as const` vs `enum`

| Feature                    | `const`                                    | `as const`                                 | `enum`                                             |
| -------------------------- | ------------------------------------------ | ------------------------------------------ | -------------------------------------------------- |
| **Primitive Narrowing**    | ‚úÖ Infers literal (`const x = 5 ‚Üí type 5`) | ‚úÖ Same effect (not useful extra)          | ‚ùå Not applicable                                  |
| **Array/Objects**          | Mutable by default                         | Deeply readonly + literal                  | Readonly by design                                 |
| **Literal Types**          | ‚ùå Only top-level primitive literals       | ‚úÖ Full literals for arrays/objects        | ‚úÖ Enum members are literals                       |
| **Readonly**               | ‚ùå Not readonly (for arrays/objects)       | ‚úÖ Full readonly (deep freeze type)        | ‚úÖ Enum values are immutable                       |
| **Runtime Representation** | Just a variable, exists at runtime         | Just a variable (type-only readonly)       | Full object-like structure at runtime              |
| **Use Case**               | Normal constants                           | Configs, status mapping, enums alternative | Traditional enums (when runtime mapping is needed) |

---

Do you want me to also add a **visual analogy example** (like `as const` = "deep freeze" vs `const` = "shallow lock") at the end for even easier recall?

---

# Video 23 ‚Äì Tuples in TypeScript

## üîπ What are Tuples?

- Tuples are basically **arrays with a fixed number of elements** where **each element has a specific type**.
- Unlike a normal array where all elements are of the same type (`number[]` or `string[]`), **tuples define exactly what type each index should have**.
- Think of it as saying:

  > ‚ÄúMy first value is a number, second value is a string, third value is boolean, fourth value is number‚Ä¶ and so on.‚Äù

**Example conceptually:**

```ts
// Normal array
const numbers: number[] = [1, 2, 3];

// Tuple: first element number, second string, third boolean
const tuple: [number, string, boolean] = [1, "hello", true];
```

---

## üîπ Why we use Tuples

1. **To enforce structure**: The order and type of elements matter, preventing mistakes.
2. **For functions that return multiple values** of different types (like `useState` in React).
3. **Type safety**: Helps ensure each position in an array has the expected type.
4. **Avoid duplication**: Tuples can replace multiple variables with a single structured return.

---

## üîπ Real-World Example: `Object.entries`

```ts
const person = {
  name: "Kyle",
  age: 28,
};

// Object.entries returns an array of tuples
Object.entries(person).forEach(([key, value]) => {
  console.log(key, value);
});
```

- Each element is a **tuple**: `[key, value]`.
- First element is always the key (`string`), second is the value (`any`).
- Tuples make this **type-safe** if we define the expected types manually.

---

## üîπ How to Define Tuples

```ts
// Hardcoded tuple: first element string, second boolean
type MyTuple = [string, boolean];

const a: MyTuple = ["hello", true]; // ‚úÖ Works
const b: MyTuple = [true, "hello"]; // ‚ùå Error: order/type mismatch
const c: MyTuple = ["hello", false, 123]; // ‚ùå Error: length mismatch
```

- Tuples **enforce length** and **type per index**.
- Useful to prevent **swapping values accidentally** or putting wrong types.

---

## üîπ Tuples in Functions

```ts
function useState<T>(initial: T): [T, (val: T) => void] {
  let state = initial;
  const setState = (val: T) => {
    state = val;
  };
  return [state, setState];
}

const [count, setCount] = useState(0);
```

- `useState` returns a **tuple** `[currentValue, updaterFunction]`.
- Tuples make **destructuring predictable and type-safe**.
- This is exactly why tuples are so common in **React** and other frameworks.

---

## üîπ Tuples vs Arrays

| Feature       | Array           | Tuple                          |
| ------------- | --------------- | ------------------------------ |
| Length        | Flexible        | Fixed                          |
| Element types | Same type only  | Different types per index      |
| Order matters | No              | Yes                            |
| Optional/Rest | Yes (with type) | Yes (can define optional/rest) |

---

## üîπ Advanced Tuple Features

1. **Readonly Tuples**

```ts
const tuple: readonly [string, number] = ["hello", 42];
tuple[0] = "world"; // ‚ùå Error
```

2. **Optional Elements**

```ts
type FlexibleTuple = [string, number?, ...boolean[]];

const t1: FlexibleTuple = ["hello"]; // ‚úÖ OK
const t2: FlexibleTuple = ["hello", 10, true, false]; // ‚úÖ OK
```

3. **Tuples with destructuring**

```ts
const user: [string, number] = ["Kyle", 28];
const [name, age] = user;
console.log(name, age); // Kyle 28
```

4. **Return types as tuples**

- Functions can **return multiple values** as a tuple instead of creating an object.

```ts
function getUser(): [string, number] {
  return ["Kyle", 28];
}
const [userName, userAge] = getUser();
```

---

## üîπ Key Nuances

- Tuples are **fixed-length**, so you cannot add extra elements that aren‚Äôt defined.
- Each element‚Äôs **type and order** are strict.
- Useful for **Object.entries**, **useState**, or **multi-value returns**.
- Can combine **readonly, optional, and rest elements**.
- Tuples make code **predictable, self-documenting, and type-safe**.

---

## ‚úÖ Summary

- **Tuples = fixed-length, ordered arrays** with different types per index.
- Enforces **type per position** and **length**, unlike normal arrays.
- Ideal for **structured returns, destructuring, and React hooks**.
- Supports **readonly, optional, and rest elements**.

---

If you want, I can now also **merge this with Video 22 `as const` and enums notes** to show **tuples + readonly + as const + enums together**, which is often how these patterns appear in real-world TypeScript projects.

Do you want me to do that?

---

Perfect üëå you already wrote the raw flow. I‚Äôll take it, polish it, add **nuances, structure (What / Why / Where / How)**, and expand on tricky points like **why `any` is bad, why extend, default generics, function + type use cases**. Let‚Äôs build your **Video 24 full notes on Generics**.

---

# Video 24 ‚Äì Generics in TypeScript

---

## üîπ What are Generics?

- **Definition**: Generics are a way to **create reusable components** (functions, types, interfaces, classes) that can work with **any type**, while still maintaining **type safety**.
- Instead of writing the same code multiple times for different types (`string`, `number`, `boolean`), we define it once and make it flexible with a **placeholder type**.
- Placeholder type is written inside **angle brackets `<T>`**.

üëâ Think of Generics as **‚Äútype variables‚Äù** you can pass into functions or types.

---

## üîπ Why We Use Generics

### Without Generics ‚Äì Problems:

1. **Too restrictive**

   ```ts
   function getSecond(array: number[]) {
     return array[1];
   }

   getSecond([1, 2, 3]); // ‚úÖ Works
   getSecond(["a", "b"]); // ‚ùå Error
   ```

   ‚Üí Works only for `number[]`.

---

2. **Union types not ideal**

   ```ts
   function getSecond(array: (string | number)[]) {
     return array[1];
   }

   getSecond([1, 2, 3]); // ‚úÖ Works
   getSecond(["a", "b"]); // ‚úÖ Works
   ```

   ‚Üí Return type is **`string | number`**, not precise.

---

3. **Using `any` loses type safety**

   ```ts
   function getSecond(array: any[]) {
     return array[1];
   }

   const ret = getSecond([1, 2, 3]);
   // ret: any ‚Üí ‚ùå we lose autocompletion, type checking, safety
   ```

   üëâ `any` means TypeScript stops helping you. This defeats the purpose.

---

‚úÖ **Generics solve this**:

- **Flexible**: Work with any type.
- **Type-safe**: Preserve the actual type info.
- **Reusable**: Define once, use everywhere.

---

## üîπ Where We Use Generics

1. **Functions** (e.g., get second element, fetch APIs).
2. **Types & Interfaces** (e.g., API responses, collections).
3. **React Hooks** (like `useState<T>`).
4. **Libraries** (e.g., Axios responses, utility functions).
5. **Built-in Types** ‚Äì `Array<T>`, `Promise<T>`, `Map<K, V>` are all generic.

---

## üîπ How We Use Generics

### 1. Basic Function Generic

```ts
function getSecond<T>(array: T[]) {
  return array[1];
}

const nums = [1, 2, 3];
const strs = ["a", "b", "c"];

const n = getSecond(nums); // n: number
const s = getSecond(strs); // s: string
```

üëâ TypeScript **infers** the type of `T`.

---

### 2. Generics in Types

```ts
type APIResponse<TData> = {
  data: TData;
  isError: boolean;
};

type UserResponse = APIResponse<{ name: string; age: number }>;
type BlogResponse = APIResponse<{ title: string }>;

const userRes: UserResponse = {
  data: { name: "Kyle", age: 28 },
  isError: false,
};

const blogRes: BlogResponse = {
  data: { title: "TS Rocks" },
  isError: false,
};
```

üëâ `APIResponse` is **reusable** for different data types.

---

### 3. Default Generic Values

```ts
type APIResponse<TData = { status: number }> = {
  data: TData;
  isError: boolean;
};

const defaultRes: APIResponse = {
  data: { status: 200 }, // ‚úÖ Uses default
  isError: false,
};

const overrideRes: APIResponse<{ message: string }> = {
  data: { message: "Hello" },
  isError: false,
};
```

üëâ Default generics prevent extra typing when most cases share a base type.

---

### 4. Constraints (`extends`)

Sometimes we want generics but with **rules**.

```ts
type APIResponse<TData extends object> = {
  data: TData;
  isError: boolean;
};

const res1: APIResponse<{ name: string }> = {
  data: { name: "Kyle" },
  isError: false,
};

const res2: APIResponse<string> = {
  data: "oops", // ‚ùå Error: string does not extend object
  isError: false,
};
```

üëâ Constraints make sure generics are used **correctly**.

---

### 5. Built-in Generics

- `Array<number>` = `number[]`
- `Promise<string>` = Promise that resolves to a string.

```ts
const arr: Array<number> = [1, 2, 3];
const promise: Promise<string> = Promise.resolve("data");
```

---

### 6. Complex Example: Converting Array ‚Üí Object

**JS version:**

```ts
function aToO(array) {
  const obj = {};
  array.forEach(([key, value]) => {
    obj[key] = value;
  });
  return obj;
}
```

**TS with Generics:**

```ts
function aToO<T>(array: [string, T][]) {
  const obj: { [index: string]: T } = {};

  array.forEach(([key, value]) => {
    obj[key] = value;
  });

  return obj;
}

const arr: [string, number | boolean][] = [
  ["keyOne", 1],
  ["keyTwo", 2],
  ["keyThree", true],
];

const obj = aToO(arr);
// obj: { keyOne: number | boolean; keyTwo: number | boolean; ... }
```

üëâ This combines **tuples + generics + index types**. Super powerful.

---

## üîπ Nuances & Best Practices

- Don‚Äôt overuse generics ‚Üí only use when **type is unknown but must stay linked**.
- Use **`extends`** for stricter control (avoid `any` sneaking in).
- Use **default generics** for common cases.
- Generics shine in **utility functions and reusable types**.
- TypeScript itself uses generics everywhere (`Array<T>`, `Record<K,V>`, etc).

---

## ‚úÖ Summary

- **What**: Generics = placeholders for types, reusable and type-safe.
- **Why**: Solve problems of restrictive, union, or `any` types.
- **Where**: Functions, API responses, React hooks, libraries, built-in types.
- **How**: `<T>` after function/type name, can extend, have defaults, or be inferred.

üëâ Always prefer generics over `any` when you want **flexibility with safety**.

---

## ‚úÖ Summary (Final + With Table)

- **What**: Generics = placeholders for types, reusable and type-safe.
- **Why**: Solve problems of restrictive, union, or `any` types.
- **Where**: Functions, API responses, React hooks, libraries, built-in types.
- **How**: `<T>` after function/type name, can extend, have defaults, or be inferred.

üëâ Always prefer generics over `any` when you want **flexibility with safety**.

---

### üîÑ Approaches Comparison (Before Generics vs With Generics)

| Approach            | Example Function                        | Works With                    | Return Type        | Problems                                                           |
| ------------------- | --------------------------------------- | ----------------------------- | ------------------ | ------------------------------------------------------------------ |
| **Specific Type**   | `function f(arr: number[]) { ... }`     | Only `number[]`               | `number`           | ‚ùå Too restrictive (can‚Äôt reuse for `string[]`, `boolean[]`, etc). |
| **Union Type**      | `function f(arr: (string \| number)[])` | `string[]`, `number[]`, mixed | `string \| number` | ‚ùå Return type becomes **broad union**, not precise.               |
| **Any Type**        | `function f(arr: any[]) { ... }`        | Any array                     | `any`              | ‚ùå Loses type safety, TS can‚Äôt help, no autocomplete.              |
| **Generic Type ‚úÖ** | `function f<T>(arr: T[]) { ... }`       | Any array                     | `T` (preserved)    | ‚úÖ Flexible + Type-safe + Reusable.                                |

---

Got it üëç tu chaahta hai isko bhi wahi detailed style me likha jaye (What, Why, Where, How, examples, nuances).
Chal main teri raw notes + aur context mila ke ekdum polished notes bana deta hoon:

---

# Video 25 ‚Äì **Async Functions & Generics in TypeScript**

---

## üîπ What Are Async Functions?

- **Definition**:
  In TypeScript (and JavaScript), **async functions** are functions that **always return a `Promise`**.

  - If you return a value, it is wrapped in a `Promise`.
  - If you throw an error, it is wrapped in a rejected `Promise`.

- Example:

  ```ts
  async function greet() {
    return "Hello"; // actually returns Promise<string>
  }

  greet().then((val) => console.log(val));
  ```

---

## üîπ Why Do We Need Generics with Async Functions?

1. **Promise values need type safety**

   - By default, `new Promise(resolve => resolve("Hi"))` ‚Üí returns `Promise<any>`.
   - Without generics, we lose type info about what the promise resolves to.

2. **Accurate autocompletion**

   - With generics, TypeScript knows whether the resolved value is `string`, `Response`, or a custom type.
   - This gives correct IntelliSense + prevents runtime mistakes.

---

## üîπ Where We Use It?

- In **functions returning Promises** (network requests, timers, async computations).
- In **`async` functions** which implicitly return `Promise<T>`.
- In **libraries like fetch, axios, database queries**, where the response type changes.

---

## üîπ How We Use It?

### 1. Without Specifying Type (‚ùå loses info)

```ts
function wait(duration: number) {
  return new Promise((resolve) => {
    setTimeout(() => resolve("Hi"), duration);
  });
}

wait(1000).then((value) => {
  console.log(value.length); // ‚ùå 'value' is 'any'
});
```

---

### 2. Adding Generic Type (‚úÖ safer)

```ts
function wait(duration: number) {
  return new Promise<string>((resolve) => {
    setTimeout(() => resolve("Hi"), duration);
  });
}

wait(1000).then((value) => {
  console.log(value.length); // ‚úÖ 'value' is string
});
```

---

### 3. Explicit Function Return Type

```ts
function wait(duration: number): Promise<string> {
  return new Promise<string>((resolve) => {
    setTimeout(() => resolve("Hi"), duration);
  });
}
```

üëâ Better practice: function signature clearly shows it **returns `Promise<string>`**.

---

### 4. Async Function Example

```ts
async function getData(): Promise<Response> {
  return await fetch("https://api.example.com/data");
}

getData().then((res) => {
  res.json().then(console.log);
});
```

- `async` keyword ensures return type is always `Promise<T>`.
- Here, function explicitly returns `Promise<Response>`.

---

### 5. With Custom Types (power of generics)

```ts
type User = { id: number; name: string };

async function fetchUser(): Promise<User> {
  const res = await fetch("/user/1");
  return res.json();
}

fetchUser().then((user) => {
  console.log(user.name); // ‚úÖ type-safe autocompletion
});
```

üëâ Generics let us define exactly what type our API returns.

---

## üîπ Nuances & Best Practices

- **Always type your Promises** ‚Üí otherwise `any` sneaks in.
- If using `async`, specify return type `Promise<T>` for clarity.
- **Don‚Äôt forget error handling** (`try/catch` or `.catch()`) ‚Üí TypeScript doesn‚Äôt enforce it.
- Generics in async code = **contracts between API and function consumer**.
- Works beautifully with `fetch`, `axios`, and other libraries that return Promises.

---

## ‚úÖ Summary

- **What**: Async functions always return a `Promise<T>`.
- **Why**: Generics give type safety + autocompletion for resolved values.
- **Where**: API calls, timers, async tasks, React hooks.
- **How**: Use `Promise<T>` return types and generics (`new Promise<T>()`).

üëâ Best practice: **always declare the promise return type explicitly**.

---

Bhai, kya main iske last me ek **Analogy** daalun (Promise = future delivery wala parcel, aur generic = kya exactly parcel ke andar hoga)? Ye tu interview me bol dega toh ekdum mast lagega. Batau, daal du?

---

Samajh gaya üëå tu keh raha hai ki jo **Person wala dusra example** tune diya tha, uska main purpose sirf ‚Äúaur ek example dikhana‚Äù nahi tha ‚Äî balki **us benefit ko highlight karna tha** jo tu last line me likh raha tha:

üëâ _‚ÄúNow the benefit of this is it also reduces code duplication ‚Äî for eg: if we change our Person type `name` to `number` it will reflect in our `SimplePerson`.‚Äù_

Matlab, tu emphasize karna chahata hai ki `Pick`/`Omit` ka **sabse bada faida** ye hai ki derived types automatically sync hote hain base type ke saath. Manual duplication me ye nahi hota.

Isliye maine neeche tere raw notes ka **full structured, verbose, easy-to-read version** bana diya hai jisme ye baat clear emphasis ke saath likhi gayi hai:

---

# Video 26 ‚Äì Pick and Omit in TypeScript

---

## üîπ What Are `Pick` and `Omit`?

- **Built-in utility types** in TypeScript that allow us to **create new types** by either:

  - **Picking** specific properties from an existing type (`Pick`).
  - **Omitting** (removing) certain properties from an existing type (`Omit`).

üëâ Both are **generic types** that operate on existing types to reduce duplication and improve maintainability.

---

## üîπ Why We Use `Pick` and `Omit`

1. **Avoid Code Duplication** ‚Äì Instead of redefining similar types manually, reuse existing ones.
2. **Stay DRY** ‚Äì If a property type changes in the base type, all derived types update automatically.
3. **Type Safety** ‚Äì Prevents errors when renaming or changing properties, since TypeScript enforces consistency.
4. **Flexibility** ‚Äì Create specialized versions of a type (e.g., "new record without id", "summary version with fewer fields").

---

## üîπ Where We Use Them

- Forms / APIs where some fields are omitted (e.g., `id` when creating a new entity).
- Derived types like "preview", "minimal info", or "read-only subset".
- React props when passing only part of a larger object.
- Database / model transformations (`NewUser`, `PublicProfile`, etc).

---

## üîπ Problem Without `Pick`/`Omit`

```ts
type Todo = {
  id: string;
  name: string;
  completed: boolean;
};

type NewTodo = {
  name: string;
  completed: boolean;
};

function saveTodo(todo: NewTodo): Todo {
  return { ...todo, id: crypto.randomUUID() };
}

function renderTodo(todo: Todo) {
  const div = document.createElement("div");
  div.id = todo.id;
}
```

üëâ Here, `NewTodo` is manually duplicated. If we change `Todo.name` to `number`, we must also update `NewTodo`.
‚ùå This is error-prone & violates DRY.

---

## üîπ Bad Alternative: Making `id` Optional

```ts
type Todo = {
  id?: string; // ‚ùå makes no sense logically
  name: string;
  completed: boolean;
};

function renderTodo(todo: Todo) {
  const div = document.createElement("div");
  div.id = todo.id; // ‚ùå Error: string | undefined
}
```

üëâ `id` shouldn‚Äôt be optional, it **always exists after saving**. This creates unnecessary type errors.

---

## üîπ Solution with `Pick`

```ts
type Todo = {
  id: string;
  name: string;
  completed: boolean;
};

type NewTodo = Pick<Todo, "name" | "completed">;

function saveTodo(todo: NewTodo): Todo {
  return { ...todo, id: crypto.randomUUID() };
}
```

‚úÖ `NewTodo` now **inherits exactly** the types from `Todo`.
If `Todo.name` changes to `number`, `NewTodo.name` also changes automatically.

---

## üîπ Solution with `Omit`

```ts
type Todo = {
  id: string;
  name: string;
  completed: boolean;
};

type NewTodo = Omit<Todo, "id">;

function saveTodo(todo: NewTodo): Todo {
  return { ...todo, id: crypto.randomUUID() };
}
```

üëâ This is **cleaner** for our use case, since we just want `Todo` **without `id`**.

---

## üîπ Another Example (Emphasizing the Benefit)

```ts
type Person = {
  id: string;
  name: string;
  age: number;
  address: {};
};

// ‚úÖ Derived types
type SimplePerson = Pick<Person, "name" | "age">;
type AnonymousPerson = Omit<Person, "id" | "address">;
```

‚ú® **The Real Benefit:**
If later we change `Person.name` ‚Üí `number`,
then **SimplePerson.name also automatically changes to number**.

üëâ This is the biggest advantage:

- **No duplication.**
- **Derived types always stay in sync with the base type.**
- **Reduces bugs + saves effort.**

---

## üîπ Nuances & Best Practices

- Use **`Pick`** when you want **a few properties only**.
  ‚Üí Example: summary version of user profile (`name`, `age`).

- Use **`Omit`** when you want **almost everything, but exclude a few properties**.
  ‚Üí Example: new entity before DB creates `id`.

- Both depend on **Generics** ‚Üí `Pick<Type, Keys>` and `Omit<Type, Keys>`.

- If you find yourself redefining similar types, think **‚ÄúCan I Pick or Omit?‚Äù**

---

## ‚úÖ Summary

- **What**: `Pick` and `Omit` are utility types to derive new types from existing ones.
- **Why**: Reduce duplication, maintain type safety, enforce DRY principle.
- **Where**: APIs, forms, React props, DB entities.
- **How**:

  - `Pick<Type, "key1" | "key2">` ‚Üí keeps only listed keys.
  - `Omit<Type, "key1" | "key2">` ‚Üí removes listed keys.

üëâ `Pick` = "include only these"
üëâ `Omit` = "exclude only these"

---

Perfect üëç Let‚Äôs create **full, in-depth notes for Video 27 ‚Äì Partial & Required in TypeScript**, just like you preferred for Video 26 (structured, verbose, and easy to explain in interviews). I‚Äôll expand with **What / Why / Where / How**, examples, comparison tables, custom utilities, and best practices.

---

# Video 27 ‚Äì `Partial` and `Required` in TypeScript

---

## üîπ What Are `Partial` and `Required`?

- **Built-in utility types** in TypeScript that modify existing types.
- They are **exact opposites**:

1. **`Partial<Type>`** ‚Üí makes **all properties optional**.
2. **`Required<Type>`** ‚Üí makes **all properties required** (removes `?`).

üëâ Both are **generic types** that transform a type instead of redefining it.

---

## üîπ Why We Use Them

1. **Flexibility in different contexts** ‚Äì Sometimes not all fields are needed (`Partial`), sometimes every field must exist (`Required`).
2. **Avoid Code Duplication** ‚Äì Instead of writing multiple versions of the same type manually.
3. **Consistency** ‚Äì If the original type changes, the derived type updates automatically.
4. **Type Safety** ‚Äì Enforces compiler rules for optional/required properties.
5. **Cleaner APIs** ‚Äì More descriptive intent: ‚Äúthis form allows partial updates‚Äù vs. ‚Äúthis DB model requires everything‚Äù.

---

## üîπ Where We Use Them

- **`Partial`** ‚Üí forms, PATCH APIs, situations where only some fields are being updated.
- **`Required`** ‚Üí database models, full objects before saving, functions that can‚Äôt accept missing data.
- **Combination with `Pick`/`Omit`** ‚Üí when only specific fields should be optional/required.

---

## üîπ How They Work

### ‚úÖ Example: `Partial`

```ts
type Todo = {
  title: string;
  completed: boolean;
};

type FormTodo = Partial<Todo>;
```

üëâ Now `FormTodo` becomes:

```ts
{
  title?: string
  completed?: boolean
}
```

_Every property becomes optional automatically._

---

### ‚úÖ Example: `Required`

```ts
type Todo = {
  title?: string;
  completed: boolean;
  address?: {
    street?: string;
  };
};

type FormTodo = Required<Todo>;
```

üëâ Now `FormTodo` becomes:

```ts
{
  title: string
  completed: boolean
  address: {
    street?: string   // ‚ö†Ô∏è still optional (Required is shallow)
  }
}
```

‚ö° **Important Note**:

- `Required` works only on **top-level properties**.
- It does **not make nested fields required**.

---

## üîπ Making Only Certain Keys Required

Sometimes we don‚Äôt want to make everything required.
üëâ Example: **only `title` should be required, rest stay optional**.

### Step 1 ‚Äì Pick & Require

```ts
type Todo = {
  title?: string;
  completed: boolean;
  address?: {
    street?: string;
  };
};
type FormTodo = Required<Pick<Todo, "title">>;
```

Result:

```ts
{
  title: string;
}
```

(but this **loses other properties**).

---

### Step 2 ‚Äì Merge with Omit

```ts
type FormTodo = Required<Pick<Todo, "title">> & Omit<Todo, "title">;
```

Result:

```ts
{
  title: string
  completed: boolean
  address?: { street?: string }
}
```

‚ú® Now we get:

- `title` ‚Üí required
- other fields ‚Üí as they were (`completed` stays required, `address` stays optional)

---

## üîπ Custom Utility Types (More Control)

To avoid repeating Pick + Omit everywhere, we can define **helper utilities**.

```ts
// ‚úÖ Make only some keys required
type RequiredPick<T, K extends keyof T> = Required<Pick<T, K>> & Omit<T, K>;

// ‚úÖ Make only some keys optional
type PartialPick<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;
```

---

### Example 1 ‚Äì Making Only `title` Optional

```ts
type Todo = {
  title: string;
  completed: boolean;
  address?: { street?: string };
};

type FormTodo = PartialPick<Todo, "title">;

const todo: FormTodo = {
  completed: true,
  // 'title' is optional here ‚úÖ
};
```

---

### Example 2 ‚Äì Making Only `title` Required

```ts
type Todo = {
  title?: string;
  completed: boolean;
  address?: { street?: string };
};

type FormTodo = RequiredPick<Todo, "title">;

const todo: FormTodo = {
  completed: true,
  title: "Task 1", // ‚úÖ required now
};
```

---

## üîπ Visual Comparison Table

| **Base Type** (`Todo`)          | **Partial<Todo>**               | **Required<Todo>**             |
| ------------------------------- | ------------------------------- | ------------------------------ |
| `title?: string`                | `title?: string`                | `title: string`                |
| `completed: boolean`            | `completed?: boolean`           | `completed: boolean`           |
| `address?: { street?: string }` | `address?: { street?: string }` | `address: { street?: string }` |

‚ú® **Observations**:

- `Partial` ‚Üí adds `?` to every property.
- `Required` ‚Üí removes `?` from every property.
- **Nested fields remain unchanged**.

---

## üîπ Visual Comparison for Custom Utilities

| **Utility**                | **Effect**                      | **Example Result (on `Todo`)**            |
| -------------------------- | ------------------------------- | ----------------------------------------- |
| `Partial<T>`               | Makes **all keys optional**     | `{ title?: string; completed?: boolean }` |
| `Required<T>`              | Makes **all keys required**     | `{ title: string; completed: boolean }`   |
| `PartialPick<T, "title">`  | Only `"title"` becomes optional | `{ title?: string; completed: boolean }`  |
| `RequiredPick<T, "title">` | Only `"title"` becomes required | `{ title: string; completed: boolean }`   |

---

## üîπ Best Practices & Nuances

1. **Use `Partial`** ‚Äì when creating forms, PATCH requests, draft objects.
2. **Use `Required`** ‚Äì when saving to DB, enforcing validation, ensuring no missing fields.
3. **Remember:** They are **shallow**, not deep ‚Üí nested optionals remain optional.
4. **Combine with `Pick`/`Omit`** for selective control.
5. **Custom utilities (`PartialPick`, `RequiredPick`)** help make the intent very clear.

---

## ‚úÖ Summary

- **What**: `Partial` ‚Üí makes all properties optional, `Required` ‚Üí makes all required.
- **Why**: Reduces duplication, improves safety, enforces intent.
- **Where**: APIs, forms, DB models, type transformations.
- **How**:

```ts
Partial<Type>; // all optional
Required<Type>; // all required
Required<Pick<Type, "key">> & Omit<Type, "key">; // selectively required
```

üëâ

- `Partial` = ‚Äúloosen constraints‚Äù
- `Required` = ‚Äútighten constraints‚Äù
- `PartialPick` / `RequiredPick` = ‚Äúfine-grained control‚Äù

---

Would you like me to also add a **real-world analogy** (like ‚Äújob application form draft vs final submitted form‚Äù) so you can **explain it conversationally in interviews** just like you prefer?

---

Got it ‚úÖ Bhai ‚Äî ab main **Video 28 ‚Äì ReturnType & Parameters** ke notes bana raha hoon, wahi **structured style** jo tu prefer karta hai (What / Why / Where / How / Examples / Nuances / Summary). Tere raw notes ko expand karke easy, interview-friendly bana deta hoon.

---

# Video 28 ‚Äì `ReturnType` and `Parameters` in TypeScript

---

## üîπ What Are `ReturnType` and `Parameters`?

- They are **built-in utility types** in TypeScript that allow us to extract type information directly from functions.

1. **`ReturnType<T>`** ‚Äì extracts the **return type** of a function.
2. **`Parameters<T>`** ‚Äì extracts the **parameters as a tuple type**.

üëâ Both utilities rely on **Generics** and expect a **function type** as input.

---

## üîπ Why We Use Them

1. **Reduce Duplication** ‚Äì Don‚Äôt manually write the return/parameter types again.
2. **Consistency** ‚Äì If the function return type or parameter types change, the extracted types update automatically.
3. **Type Safety** ‚Äì Avoids mistakes when manually guessing return/parameter types.
4. **Refactor Friendly** ‚Äì Great for large codebases where functions evolve over time.
5. **Dynamic Utility** ‚Äì Useful in scenarios like higher-order functions, middleware, APIs, etc.

---

## üîπ Where We Use Them

- When writing **types for functions you didn‚Äôt author** (like library functions).
- When writing **generic utilities** that depend on another function‚Äôs input/output.
- Middleware, API handlers, validators where parameter & return signatures matter.
- React hooks (extracting return type of `useState`, etc).

---

## üîπ How to Use `ReturnType`

### Example 1 ‚Äì Extracting Return Type

```ts
function checkLength(a: string, b: number) {
  return a.length < b;
}

type ReturnOfCheckLength = ReturnType<typeof checkLength>;
// ‚úÖ boolean
```

üëâ Notice we used `typeof checkLength` because `ReturnType` expects a **function type**, not the function itself.

---

### Example 2 ‚Äì With Explicit Function Type

```ts
type Func = () => void;

type ReturnOfFunc = ReturnType<Func>;
// ‚úÖ void
```

üëâ If you already have a function type (`Func`), no need for `typeof`.

---

## üîπ How to Use `Parameters`

### Example 1 ‚Äì Extracting Parameters

```ts
function checkLength(a: string, b: number) {
  return a.length < b;
}

type Params = Parameters<typeof checkLength>;
// ‚úÖ [a: string, b: number]
```

üëâ `Parameters` returns a **tuple** representing all arguments of the function.

---

### Example 2 ‚Äì Getting Specific Parameter

```ts
type SecondParam = Parameters<typeof checkLength>[1];
// ‚úÖ number
```

üëâ Useful when you only care about one parameter type.

---

## üîπ Nuances & Best Practices

1. **Use `typeof`** when passing a function **directly**.
   ‚Üí `ReturnType<typeof fn>` ‚úÖ
   ‚Üí `ReturnType<fn>` ‚ùå (error).

2. **Parameters returns a tuple** ‚Üí can destructure or access via index.

3. **Real-world use case**:

   - For functions like `fetch`, `ReturnType<typeof fetch>` gives `Promise<Response>`.
   - For hooks: `ReturnType<typeof useState<string>>` gives `[string, Dispatch<SetStateAction<string>>]`.

4. **Great for higher-order functions**:
   Ensures wrapper functions return/accept exactly what the original does.

---

## üîπ Comparison Table

| **Utility**        | **What it Does**               | **Example Input**    | **Output**         |
| ------------------ | ------------------------------ | -------------------- | ------------------ |
| `ReturnType<T>`    | Extracts function return type  | `typeof checkLength` | `boolean`          |
| `Parameters<T>`    | Extracts parameters as tuple   | `typeof checkLength` | `[string, number]` |
| `Parameters<T>[0]` | Extracts first parameter type  | `typeof checkLength` | `string`           |
| `Parameters<T>[1]` | Extracts second parameter type | `typeof checkLength` | `number`           |

---

## ‚úÖ Summary

- **What**:

  - `ReturnType<T>` ‚Üí extracts the return type of a function.
  - `Parameters<T>` ‚Üí extracts parameters as a tuple.

- **Why**: Avoid duplication, improve safety, keep types consistent when functions change.

- **Where**: APIs, middleware, hooks, validators, generic utilities.

- **How**:

```ts
ReturnType<typeof fn>; // gets return type
Parameters<typeof fn>; // gets [param1, param2, ...]
Parameters < typeof fn > [0]; // gets first parameter
```

üëâ Think of these as **‚Äútype mirrors‚Äù** for functions: they reflect back the inputs & outputs without rewriting them.

---

Bhai, chaahe toh main isme ek **real-world analogy** bhi dal sakta hoon, jaise `ReturnType` = ‚Äúwhat comes out of the machine‚Äù, `Parameters` = ‚Äúwhat you need to feed into the machine‚Äù. Kya tu chahata hai ki woh bhi add kar du for interview-friendly explanation?

---

Perfect üëå You‚Äôve already captured the raw essence. Let‚Äôs now structure this into **complete, deep, interview-ready notes for Video 29 (Record)**, including why the code looks weird, what it‚Äôs doing, how `Record` works, and the subtle nuances behind using `Record` vs. index signatures.

---

# Video 29 ‚Äì `Record` in TypeScript

## 1. What‚Äôs happening in this code?

```ts
type Person = {
  name: string;
  age: number;
};

type PeopleGroupedByName = {
  [index: string]: Person[];
};
```

- This is a **TypeScript index signature**.
- It says:

  - The **keys** of this object will be strings (`[index: string]`).
  - The **values** for each key must be an **array of `Person` objects** (`Person[]`).

üëâ Example usage:

```ts
const grouped: PeopleGroupedByName = {
  Alice: [{ name: "Alice", age: 25 }],
  Bob: [
    { name: "Bob", age: 20 },
    { name: "Bob", age: 30 },
  ],
};
```

So essentially, we are creating a dictionary / map-like object where:

- Key = **string** (the grouping criteria, e.g., a person‚Äôs name).
- Value = **Person[]** (all people with that name).

---

## 2. Why does it look confusing / "WTF"?

Because it‚Äôs a **manual index signature**. It looks low-level, like you‚Äôre telling TypeScript:

> ‚ÄúWhatever string you put as a key, its value must be an array of `Person`.‚Äù

This is powerful but verbose. TypeScript already provides a **built-in utility type** called `Record` that makes this exact pattern easier.

---

## 3. Using `Record` instead

Instead of:

```ts
type PeopleGroupedByName = {
  [index: string]: Person[];
};
```

We can write:

```ts
type PeopleGroupedByName = Record<string, Person[]>;
```

‚úÖ Both are identical under the hood.

- `string` ‚Üí key type.
- `Person[]` ‚Üí value type.

üëâ Example is the same:

```ts
const grouped: PeopleGroupedByName = {
  Alice: [{ name: "Alice", age: 25 }],
  Bob: [{ name: "Bob", age: 30 }],
};
```

---

## 4. Why use `Record`?

- **Readability:** More concise and declarative. Anyone can instantly see it means _‚Äúkeys are strings, values are `Person[]`‚Äù_.
- **Consistency:** When writing complex mapped types, `Record` looks cleaner.
- **Behind the scenes:** `Record<K, T>` is just:

  ```ts
  type Record<K extends keyof any, T> = {
    [P in K]: T;
  };
  ```

So `Record<string, Person[]>` is literally sugar for `{ [index: string]: Person[] }`.

---

## 5. Being more specific

We can go beyond just `"string"` and tie it back to **actual types** in our model:

```ts
type Person = {
  name: string;
  age: number;
};

type PeopleGroupedByName = Record<Person["name"], Person[]>;
```

### What‚Äôs happening here?

- Instead of `Record<string, Person[]>`, we used `Person["name"]`.
- `Person["name"]` means ‚Üí "the type of the `name` property in `Person`".
- Currently `Person["name"]` = `string`.
- So right now, it‚Äôs still equivalent to `Record<string, Person[]>`.

---

## 6. But what‚Äôs the **benefit** of using `Person["name"]` instead of `string`?

Here‚Äôs the nuance üëá

- If tomorrow we **change** `Person` so that `name` is a `number` instead of `string`:

```ts
type Person = {
  name: number; // changed from string ‚Üí number
  age: number;
};
```

- Then this automatically updates:

```ts
type PeopleGroupedByName = Record<Person["name"], Person[]>;
```

Now `PeopleGroupedByName` becomes `Record<number, Person[]>`.

‚úÖ This means we don‚Äôt have to manually update `"string"` ‚Üí `"number"` everywhere else.
üëâ So it‚Äôs **future-proof** and keeps our types in sync with model changes.

---

## 7. Summary

- **Index signature:** `{ [key: string]: Person[] }` ‚Üí tells TS keys are strings, values are `Person[]`.
- **Record utility type:** `Record<string, Person[]>` ‚Üí shorthand for the same thing, cleaner.
- **Specific keys with model references:** `Record<Person["name"], Person[]>` ‚Üí ties key type to actual property type, making code resilient to changes.
- **Main use case:** Creating objects with dynamic keys but consistent value shapes (like grouping, caching, mapping, dictionary structures).

---

‚úÖ Example in practice:

```ts
const grouped: PeopleGroupedByName = {
  Alice: [
    { name: "Alice", age: 20 },
    { name: "Alice", age: 25 },
  ],
  Bob: [{ name: "Bob", age: 30 }],
};

// If Person["name"] = number, then the keys here must be numbers, not strings.
```

---

‚ö°Ô∏èIn short:

- Use `Record` for clean, consistent typing of key-value maps.
- Use `Person["name"]` (or similar property references) to make types automatically update when your model changes.

---

Do you want me to also **add a practical example** of using `Record` in a **real project scenario** (like grouping by department, caching API data, etc.) so your notes become more application-focused and interview-solid?

---

Perfect, let‚Äôs polish and expand your raw notes into **detailed, structured notes for Video 30 (Readonly type)** ‚Äî with full depth, practical nuances, and clarity üëá

---

# Video 30 ‚Äì Readonly Type in TypeScript

## 1. What is `Readonly`?

- `Readonly<T>` is a **TypeScript utility type**.
- It takes an object type `T` and marks **all of its properties as immutable (cannot be reassigned)**.
- Very similar to `Partial<T>` and `Required<T>`, but instead of toggling optionality, it toggles **mutability**.

üëâ Example:

```ts
type Todo = {
  title: string;
  completed: boolean;
};

type FinalTodo = Readonly<Todo>;

const todo: FinalTodo = {
  title: "Learn TS",
  completed: false,
};

// ‚ùå Error: Cannot assign to 'title' because it is a read-only property.
todo.title = "Learn React";
```

So once you wrap a type with `Readonly`, you cannot reassign its properties.

---

## 2. Relation to `as const`

- `as const` is a **JavaScript/TS expression-level feature**.
- It tells TypeScript to **freeze** the value:

  - Make object properties `readonly`.
  - Narrow literal types (e.g., `"sdf"` instead of `string`).

Example:

```ts
const todo = {
  title: "sdf",
  completed: false,
} as const;

// 'todo.title' is readonly and type is "sdf" (not string).
// 'todo.completed' is readonly and type is false (not boolean).
```

Here, `as const` works only on **actual values (runtime JS objects)**.

But with `Readonly<T>`, we can apply immutability at the **type level**, not just on inline objects.

---

## 3. Key Difference: `Readonly<T>` vs. `as const`

| Feature         | `Readonly<T>` (type utility)                                                | `as const` (value assertion)                             |
| --------------- | --------------------------------------------------------------------------- | -------------------------------------------------------- |
| Scope           | Works at the **type level**                                                 | Works at the **value level**                             |
| When used?      | When defining reusable types or enforcing immutability in interfaces/models | When freezing **inline objects, arrays, or literals**    |
| Property effect | Makes all properties `readonly`                                             | Makes properties `readonly` + narrows values to literals |
| Example change? | Works on `Todo` type                                                        | Works only on `const todo = {...}` object                |

üëâ If you only need to freeze a literal object, use `as const`.
üëâ If you need to enforce immutability across many objects via types, use `Readonly<T>`.

---

## 4. Real-world use cases

- **Config objects:**

```ts
type Config = {
  apiUrl: string;
  retries: number;
};

const appConfig: Readonly<Config> = {
  apiUrl: "https://api.example.com",
  retries: 3,
};

// ‚ùå appConfig.apiUrl = "http://localhost"; (not allowed)
```

- **Prevent accidental mutations in function arguments:**

```ts
type Todo = {
  title: string;
  completed: boolean;
};

function printTodo(todo: Readonly<Todo>) {
  console.log(todo.title);

  // ‚ùå Cannot modify
  // todo.completed = true;
}
```

- **Working with libraries / immutability patterns (like Redux):**

  - Enforcing that state objects cannot be mutated directly.
  - Instead, new objects must be created.

---

## 5. Combining with other utilities

- You can combine `Readonly` with `Partial`, `Pick`, etc., for finer control.

Example:

```ts
type Todo = {
  title: string;
  completed: boolean;
  dueDate?: Date;
};

// Make only 'title' readonly, others normal
type ReadonlyTitle = Readonly<Pick<Todo, "title">> & Omit<Todo, "title">;

const todo: ReadonlyTitle = {
  title: "Immutable Title",
  completed: false,
};

// ‚ùå todo.title = "Change"; (readonly)
// ‚úÖ todo.completed = true;
```

---

## 6. Summary

- **`Readonly<T>`** = makes all properties of `T` immutable.
- **`as const`** = freezes inline values, makes them `readonly` + narrows literals.
- Use `Readonly<T>` for **types/interfaces**.
- Use `as const` for **object literals/arrays**.
- Very useful in **immutability patterns**, function arguments, and preventing accidental mutations in shared objects.

---

‚ö° So think of it like this:

- `as const` ‚Üí Quick freeze of **a single literal object**.
- `Readonly<T>` ‚Üí Enforce immutability at **type system scale**.

---

Do you want me to also show how **`ReadonlyArray`** (built-in TS type) fits into this topic? It‚Äôs closely related and often asked in interviews.

---

Perfect üëå I got your raw draft. Let me **expand + clean + structure** it like your preferred format (like we did in Video 26‚Äì30). Here‚Äôs the full **Video 31 ‚Äì Awaited** notes with depth, examples, and clarity:

---

# Video 31 ‚Äì Awaited Utility Type in TypeScript ------------------

---

## üîπ What is `Awaited`?

- `Awaited<T>` is a **built-in utility type** in TypeScript.
- Its purpose: **unwrap the resolved value of a `Promise`**.
- Works with both **simple** and **nested Promises**.

üëâ In short: **`Awaited` gives us the type that we‚Äôd get if we actually wrote `await something`.**

---

## üîπ Why Do We Use `Awaited`?

1. **Extract actual return value** from a `Promise<T>`.
   ‚Üí Example: `Promise<number>` ‚Üí `number`.
2. **Handles nested Promises** (Promise inside Promise).
3. **Works great with `ReturnType`** to infer async function results.
4. **Avoids manual duplication** ‚Äì no need to define result type separately.
5. **Improves type safety** in async-heavy code (APIs, DB queries, fetch).

---

## üîπ Example 1: Basic Usage

```ts
type AsyncString = Promise<string>;

type Value = Awaited<AsyncString>;
// ‚úÖ Value = string
```

---

## üîπ Example 2: Nested Promise

```ts
type Async = Promise<Promise<string>>;

type Value = Awaited<Async>;
// ‚úÖ Value = string
```

üëâ `Awaited` keeps unwrapping until it reaches the final resolved type.

---

## üîπ Example 3: Inside Async Function

```ts
async function doSomething() {
  return 3;
}

// ReturnType gives the raw function return
type RawReturn = ReturnType<typeof doSomething>;
// ‚úÖ RawReturn = Promise<number>

// Awaited unwraps it
type Value = Awaited<ReturnType<typeof doSomething>>;
// ‚úÖ Value = number
```

‚ú® This is the **most common pattern** ‚Äì combining `Awaited` with `ReturnType` to know exactly what an async function resolves to.

---

## üîπ Example 4: Real-World API

```ts
async function fetchUser() {
  return { id: 1, name: "Alice" };
}

// Without Awaited
type UserPromise = ReturnType<typeof fetchUser>;
// ‚úÖ UserPromise = Promise<{ id: number; name: string }>

// With Awaited
type User = Awaited<ReturnType<typeof fetchUser>>;
// ‚úÖ User = { id: number; name: string }
```

üëâ Super useful for APIs, DB queries, or any async logic.

---

## üîπ Internal Definition of `Awaited` (Simplified)

```ts
type Awaited<T> = T extends null | undefined
  ? T
  : T extends PromiseLike<infer U>
  ? Awaited<U>
  : T;
```

- If type is a `PromiseLike`, it **unwraps**.
- If nested, it **recursively unwraps**.
- Otherwise, it just returns the type itself.

---

## üîπ Comparison With `typeof await`

In practice:

```ts
const result = await doSomething();
// typeof result = number
```

But if you need to **extract this type without running code** ‚Üí use `Awaited<ReturnType<typeof fn>>`.

üëâ This makes `Awaited` especially valuable in **type definitions, utility types, and libraries**.

---

## ‚úÖ Summary

- **What:** `Awaited<T>` unwraps Promises and gives the resolved value.
- **Why:** To safely extract async results, handle nested Promises, and combine with `ReturnType`.
- **Where:** APIs, DB queries, async helpers, libraries.
- **How:**

```ts
Awaited<Promise<string>>; // ‚Üí string
Awaited<Promise<Promise<number>>>; // ‚Üí number
Awaited<ReturnType<typeof asyncFn>>; // ‚Üí resolved type
```

üëâ Think of `Awaited<T>` as **‚Äúthe type you get after using `await` in code.‚Äù**

---

Do you want me to also add a **side-by-side table** (like: _Without Awaited ‚Üí With Awaited_) for async function returns? It would make the difference even more crystal clear.

---

Perfect üëå Chal Video 32 ko ab usi structured style me likh deta hoon ‚Äî **What / Why / Where / How / Examples / Nuances / Summary**, easy English, interview-friendly:

---

Ah got it! You want me to **keep all your original code, explanations, and examples exactly as you wrote them**, and just **format and structure** them into the What / Why / Where / How / Examples / Nuances / Summary style **without changing any content**. Here's the full Video 32 notes in that style:

---

# Video 32 ‚Äì Basic Type Guards

---

## üîπ What

- Type Guards in TypeScript are used to **narrow down the type** of a variable within a block so we can safely work with it.
- Type narrowing helps when a variable can have **multiple types** (union types), like `string | Date | number`.

---

## üîπ Why

- To **avoid runtime errors** when accessing properties or methods that only exist on a specific type.
- To **safely work with optional properties** or values that can be `null` or `undefined`.
- To make code **more readable and type-safe**.

---

## üîπ Where

- Union types (`string | Date | number`)
- Optional properties (`description?: string`)
- DOM elements that might be `null` (`document.querySelector`)
- Literal unions (`"High" | "Normal" | "Low"`)

---

## üîπ How / Examples

### 1. `typeof` for type narrowing

```ts
type Todo = {
  title: string;
  priority: "High" | "Normal" | "Low";
  isComplete: boolean;
  description?: string;
  dueDate: Date | string;
};

function extendTodo(todo: Todo) {
  if (typeof todo.dueDate === "string") {
    // Inside this block, todo.dueDate is narrowed to string
  } else {
    // Inside this block, todo.dueDate is narrowed to Date
    console.log(todo.dueDate.getDate);
  }
}
```

---

### 2. `instanceof` for objects/classes

```ts
type Todo = {
  title: string;
  priority: "High" | "Normal" | "Low";
  isComplete: boolean;
  description?: string;
  dueDate: Date | string | number;
};

function extendTodo(todo: Todo) {
  if (todo.dueDate instanceof Date) {
    // Inside this block, todo.dueDate is narrowed to Date
    console.log(todo.dueDate);
  } else {
    // Inside this block, todo.dueDate is narrowed to string | number
    console.log(todo.dueDate);
  }
}
```

---

### 3. Optional chaining `?.`

```ts
type Todo = {
  title: string;
  priority: "High" | "Normal" | "Low";
  isComplete: boolean;
  description?: string;
  dueDate: Date | string;
};

function extendTodo(todo: Todo) {
  todo.description?.length;
  // The optional chaining operator (?.) is used here because 'description' is an optional property (description?: string).
  // This prevents a runtime error if 'description' is undefined.
}
```

---

### 4. Non-null assertion `!`

```ts
const form = document.querySelector<HTMLFormElement>(".form");
form!.addEventListener("submit", () => {});
// The ! tells TypeScript this value is never null or undefined
```

_Note:_ We can put `!` anywhere to **override TypeScript null/undefined checks**.

```ts
const form = document.querySelector<HTMLFormElement>(".form")!;
form.addEventListener("submit", () => {});
```

---

### 5. `switch` statements for narrowing literal unions

```ts
type Todo = {
  title: string;
  priority: "High" | "Normal" | "Low";
  isComplete: boolean;
  description?: string;
  dueDate: Date | string;
};

function extendTodo(todo: Todo) {
  switch (todo.priority) {
    case "High":
      console.log(todo.priority);
      break;
    case "Normal":
      console.log(todo.priority);
      break;
    case "Low":
      console.log(todo.priority);
      break;
  }
}
```

---

## üîπ Nuances

- `typeof` ‚Üí only for **primitive types** (`string`, `number`, `boolean`).
- `instanceof` ‚Üí for **objects and classes** (`Date`, `Array`).
- `?.` ‚Üí optional chaining prevents runtime errors for optional properties.
- `!` ‚Üí use **carefully** to assert non-nullable values.
- `switch` ‚Üí good for **literal union types** for clean type narrowing.

---

## ‚úÖ Summary

- Type Guards help TypeScript **narrow variable types** in a safe way.
- They allow safe access to properties/methods on variables with **union types** or optional/null values.
- Techniques include:

  - `typeof` ‚Üí primitive type checking
  - `instanceof` ‚Üí class/object type checking
  - `?.` ‚Üí optional chaining
  - `!` ‚Üí non-null assertion
  - `switch` ‚Üí literal union narrowing

---

If you want, I can do the **same exact depth formatting** for **Video 27‚Äì31** so all your notes are in one **uniform, interview-ready style**.

Do you want me to do that?

---

Perfect! Let‚Äôs expand your **Video 33 ‚Äì Never Type** notes into the structured, interview-friendly format while keeping all your content intact.

---

# Video 33 ‚Äì Never Type

---

## üîπ What

- The **`never` type** in TypeScript represents values that **should never occur**.
- It‚Äôs used for **exhaustive type checking**, usually in **switch statements** or **function return types** that should never be reached.
- Helps ensure that **all possible cases** are handled and signals errors if a case is forgotten.

---

## üîπ Why

- To catch **unhandled cases** in a union type at compile time.
- To make **switch statements exhaustive**, i.e., TypeScript will alert you if you forget a value.
- Acts as a **safety net**: if something truly impossible happens, TypeScript can signal it.
- Reduces bugs by enforcing **type completeness**.

---

## üîπ Where

- In **switch statements** for **union types**, e.g., `"High" | "Normal" | "Low"`.
- In **functions that never return**, e.g., `throw` or infinite loops.
- For **default cases** where a value should never exist.
- In **type guards** to assert that all other cases are handled.

---

## üîπ How

### Example ‚Äì Exhaustive Checking in Switch

```ts
type Todo = {
  title: string;
  priority: "High" | "Normal" | "Low";
  isComplete: boolean;
  description?: string;
  dueDate: Date | string;
};

function extendTodo(todo: Todo) {
  switch (todo.priority) {
    case "High":
      console.log(todo.priority);
      break;
    case "Normal":
      console.log(todo.priority);
      break;
    case "Low":
      console.log(todo.priority);
      break;

    default:
      const exhaustiveCheck: never = todo.priority;
      return exhaustiveCheck;
  }
}
```

- `exhaustiveCheck` is of type `never`.
- If all possible `priority` values are handled, the default block **never runs**.
- If a new value (e.g., `"Super High"`) is added to `Todo.priority` but **not handled**, TypeScript will throw a **compile-time error**.

---

### Using `never` with ‚Äúimpossible‚Äù code

```ts
function impossibleFunction(): never {
  throw new Error("This should never be called");
}
```

- Functions that **never return** can also be typed as `never`.

---

## üîπ Examples

1. **Exhaustive switch with never**:

```ts
switch (todo.priority) {
  case "High":
    break;
  case "Normal":
    break;
  case "Low":
    break;
  default:
    const exhaustiveCheck: never = todo.priority; // TS error if unhandled case exists
    return exhaustiveCheck;
}
```

2. **Function that never returns**:

```ts
function fail(): never {
  throw new Error("Unexpected error");
}
```

---

## üîπ Nuances

- `never` is **different from `void` or `undefined`**:

  - `void` ‚Üí function returns but with no meaningful value.
  - `never` ‚Üí function **cannot return at all**.

- In exhaustive checks, `never` **forces developers to handle all possible values**.
- Helps **maintain type safety** when union types grow over time.
- Using `never` is a **compile-time safety mechanism**, not a runtime feature.

---

## ‚úÖ Summary

- **What**: `never` type represents **values that should never occur**.
- **Why**: Ensures **exhaustive handling** and prevents bugs from unhandled cases.
- **Where**: Union types in switches, functions that never return, type guards.
- **How**:

  - Assign `never` to a variable in default block to catch unhandled cases.
  - Use in functions that always throw or never complete.

üëâ **Key Idea**: If TypeScript allows a value to reach a `never` type, it signals **compile-time error** ‚Äî helping you catch missing cases before runtime.

---

Perfect! Let‚Äôs expand **Video 34 ‚Äì Unknown Type** into the structured, interview-friendly notes like before, keeping your content intact and in-depth.

---

# Video 34 ‚Äì Unknown Type

---

## üîπ What

- The **`unknown` type** in TypeScript is similar to `any`, but **much safer**.
- It represents a value **whose type is not known at the moment**.
- Unlike `any`, you **cannot directly perform operations** on an `unknown` variable without **type checking or type assertions**.

---

## üîπ Why

- Using `unknown` **forces type safety**.
- Prevents accidental operations on a variable whose type is not guaranteed.
- Encourages **type narrowing** before using the value, unlike `any` which **turns off type checking** entirely.
- Ideal when dealing with **external data** (APIs, user input) where the type is unknown initially.

---

## üîπ Where

- Functions receiving **dynamic input** or **external data**, e.g., API responses.
- Any place where you want **strict type safety** while still accepting unknown data.
- Scenarios where `any` is tempting but would **silence TypeScript‚Äôs type checks**.

---

## üîπ How

### Basic Example ‚Äì Type Narrowing

```ts
function func(data: unknown) {
  if (
    data != null &&
    typeof data === "object" &&
    "name" in data &&
    typeof (data as { name: unknown }).name === "string"
  ) {
    // After all checks, TypeScript narrows 'data' to { name: string }
    console.log(data.name.length);
  }
}
```

**Explanation of steps:**

1. **Check for null/undefined** ‚Üí `data != null`.
2. **Check if it‚Äôs an object** ‚Üí `typeof data === "object"`.
3. **Check if property exists** ‚Üí `"name" in data`.
4. **Check property type** ‚Üí `typeof (data as { name: unknown }).name === "string"`.

- After these checks, TypeScript **safely infers** that `data` has a `name` property of type `string`.
- Without these checks, any operation like `data.name.length` would result in a **compile-time error**.

---

## üîπ Examples

1. **Dynamic API response**:

```ts
function handleApiResponse(response: unknown) {
  if (response && typeof response === "object" && "id" in response) {
    const id = (response as { id: number }).id;
    console.log(id);
  }
}
```

2. **Unknown vs Any**:

```ts
let valueAny: any;
let valueUnknown: unknown;

valueAny.foo(); // ‚úÖ compiles, but unsafe
valueUnknown.foo(); // ‚ùå TypeScript error, must narrow first
```

---

## üîπ Nuances

- `unknown` is **much safer than `any`**.
- Forces **explicit type checking** or **type assertions**.
- TypeScript will **not allow operations** without narrowing: e.g., cannot access properties, call methods, or perform arithmetic.
- Works well with **type guards** for runtime safety.
- Helps maintain **typesafety even with external data**.

---

## ‚úÖ Summary

- **What**: `unknown` represents a value whose type is not known at compile time.
- **Why**: Ensures **type safety** while still accepting unknown values.
- **Where**: Dynamic input, API responses, external data.
- **How**:

  - Use **type narrowing** (`typeof`, `instanceof`, `in`) before performing operations.
  - Use **type assertions** if necessary, but only after proper checks.

üëâ **Key Idea**: `unknown` preserves TypeScript‚Äôs type safety while allowing flexible handling of dynamic data, unlike `any` which disables all type checks.

---

Perfect! Let's expand **Video 35 ‚Äì `as` Casting** into the structured, interview-friendly notes in the same style you like (What / Why / Where / How / Examples / Nuances / Summary) without changing your content:

---

# Video 35 ‚Äì `As` Casting (Type Assertion)

---

## üîπ What

- **`as` casting (type assertion)** in TypeScript is a way to **tell the compiler what type a value should be treated as**.
- It sits **between `any` and `unknown`**:

  - Unlike `any`, it **doesn‚Äôt disable type checking** for the rest of the code.
  - Unlike `unknown`, it **doesn‚Äôt require extensive type narrowing**.

- Essentially, it is a way to **inform TypeScript** about the expected type when you already ‚Äúknow‚Äù the shape of the value.

---

## üîπ Why

- Using `any` everywhere makes TypeScript **lose type safety** in surrounding code.
- Using `unknown` forces **explicit type checks**, which can be **tedious and verbose** for complex objects.
- `as` casting provides a **middle ground**:

  - Retains **type safety** for the rest of the code.
  - Avoids writing hundreds of lines of checks for complex objects (e.g., API responses).

---

## üîπ Where

- **Fetching data** from an API when you know the shape of the returned data.
- Working with **complex objects** where doing full type checking is impractical.
- Anywhere you need **type safety** but don‚Äôt want to do **manual type narrowing** everywhere.

---

## üîπ How

### Example: Fetching Data and Casting

```ts
type Todo = {
  title: string;
};

fetch("sdf")
  .then((res) => res.json())
  .then((data) => {
    return data as Todo; // Type assertion: telling TypeScript to treat the 'data' as 'Todo'
  })
  .then((todo) => {
    // 'todo' here is of type 'Todo'
    console.log(todo.title);
  });
```

### Example: Casting Variables

```ts
const a: any = 2;

const b = a as string; // 'b' is now treated as a string
```

- Here, we‚Äôre **informing TypeScript** that `b` should be treated as a string, even though `a` is `any`.

---

## üîπ Nuances & Best Practices

- **Type assertion doesn‚Äôt perform runtime checks** ‚Üí it only affects TypeScript‚Äôs type system.
- Use **`as`** only when you are **sure of the type**; otherwise, it may hide bugs.
- It‚Äôs **perfect for middle-ground scenarios**:

  - Not as unsafe as `any`.
  - Not as verbose as `unknown` with manual checks.

- Avoid **overusing** it; type assertions should be reserved for situations where **you have certainty** about the value‚Äôs type.

---

## ‚úÖ Summary

- **What**: `as` casting is a way to tell TypeScript to treat a value as a specific type.
- **Why**: Combines type safety with minimal boilerplate, unlike `any` or `unknown`.
- **Where**: API responses, complex objects, or any value where the type is known but TypeScript can‚Äôt infer it.
- **How**: Use `value as Type` to assert the type.

üëâ **Key Idea**: `as` casting gives TypeScript **the type hint it needs** without losing type safety for the rest of the code.

---

Perfect! Let‚Äôs expand **Video 36 ‚Äì `satisfies` keyword** in your preferred structured, interview-friendly style:

---

# Video 36 ‚Äì Satisfies Keyword

---

## üîπ What

- The **`satisfies`** operator in TypeScript allows you to **ensure an object conforms to a specific type** while **preserving the actual inferred types** of its properties.
- Unlike a type assertion (`as`), `satisfies` **checks compatibility** without **widening the property types**.
- Essentially, it‚Äôs a **type-safe way to enforce that an object meets a certain interface or type**.

---

## üîπ Why

- TypeScript can **sometimes fail to narrow types** correctly, especially in objects with union types (`string | Date`) or mismatched property names.
- Without `satisfies`:

  - TS may widen types unnecessarily.
  - You may need **manual type assertions** to satisfy the compiler.

- `satisfies` solves this by:

  - Ensuring the object **matches the expected type**.
  - **Preserving precise property types** (prevents unwanted widening).

---

## üîπ Where

- When defining **complex objects** that should match an interface but **retain precise property types**.
- When working with **union types or literals** where TS might otherwise widen types.
- Useful for **config objects, constants, or structured data** in large codebases.

---

## üîπ How

### Example: Without `satisfies` (Problems)

```ts
type Todo = {
  title: string;
  dueDate: string | Date;
  isComplete: boolean;
};

const todo = {
  title: "sdf",
  dueDate: new Date(),
  complete: true, // ‚ùå Property name mismatch
};

// TypeScript cannot guarantee 'dueDate' is Date (could be string)
todo.dueDate.setDate(4); // ‚ùå Error
```

- Issues:

  - Mismatched property name (`complete` vs `isComplete`)
  - `dueDate` type not narrowed ‚Üí cannot use `Date` methods

---

### Example: Using `satisfies` (Solution)

```ts
type Todo = {
  title: string;
  dueDate: string | Date;
  isComplete: boolean;
};

const todo = {
  title: "sdf",
  dueDate: new Date(),
  isComplete: true,
} satisfies Todo;

// ‚úÖ TS knows:
// 1. 'todo' matches the structure of Todo
// 2. 'dueDate' remains 'Date' (not widened)
todo.dueDate.setDate(4); // ‚úÖ Works
```

- Key benefits:

  - **Structural check**: TS verifies the object satisfies the `Todo` type.
  - **Preserved type**: Exact property types are kept (`Date` instead of `string | Date`).

---

## üîπ Nuances & Best Practices

- `satisfies` **does not cast** the object like `as` ‚Üí safer than assertions.
- Always use `satisfies` when:

  - You want **compile-time verification** of object shape.
  - You want to **avoid type widening**.

- Use in combination with **literal types** to preserve exact values:

```ts
const levels = {
  high: "high",
  low: "low",
} satisfies Record<string, string>;
```

- Cannot override TypeScript‚Äôs type inference, it only **checks compatibility**.

---

## ‚úÖ Summary

- **What**: `satisfies` checks that an object conforms to a type **without losing precise property types**.
- **Why**: Prevents type widening, preserves type safety, avoids manual type assertions.
- **Where**: Complex objects, constants, union types, config objects.
- **How**: Use `object satisfies Type` instead of `as Type`.

üëâ **Key Idea**: `satisfies` = **type enforcement + precise property types** + **compile-time safety**.

---

---

# Video 37 ‚Äì Discriminated Union

---

## üîπ What

- **Discriminated Union** (also called **tagged union**) is a TypeScript technique that allows you to **narrow down types in a union based on a specific property or flag** (the ‚Äúdiscriminator‚Äù).
- It‚Äôs used when a type can have **multiple variants**, and you want TypeScript to know **exactly which variant you are working with** based on a literal property.

---

## üîπ Why

- When using a union type like:

```ts
type UserApiResponse = {
  status: "Error" | "Success";
  data?: { id: string; name: string };
  errorMessage?: string;
};
```

- TypeScript cannot guarantee that `data` or `errorMessage` exist inside `if/else` blocks because they are optional.
- This leads to **potential runtime errors** if you try to access `.name` or `.length`.
- **Discriminated unions** fix this by making properties **required only in specific variants**, allowing safe access without type assertions.

---

## üîπ Where

- Handling **API responses** with multiple possible outcomes (success/error).
- Working with **union types where certain fields exist only for specific cases**.
- Anywhere you want **type-safe narrowing based on a literal property**.

---

## üîπ How

### Problem Example (Optional Fields Cause Errors)

```ts
type UserApiResponse = {
  status: "Error" | "Success";
  data?: { id: string; name: string };
  errorMessage?: string;
};

function handleResponse(res: UserApiResponse) {
  if (res.status === "Success") {
    // ERROR: 'data' is still optional here. 'res.data' could be undefined.
    console.log(res.data.name); // ‚ùå Error: 'data' may be undefined
  } else {
    // ERROR: 'errorMessage' is still optional here. 'res.errorMessage' could be undefined.
    console.log(res.errorMessage.length);
  }
}
```

- `res.data` and `res.errorMessage` are optional (`?`) ‚Üí TS cannot safely access them.

---

```typescript
type UserApiResponse = {
  status: "Error" | "Success";
  data?: { id: string; name: string };
  errorMessage?: string;
};

function handleResponse(res: UserApiResponse) {
  if (res.status === "Success") {
    // ERROR: 'data' is still optional here. 'res.data' could be undefined.
    console.log(res.data.name);
  } else {
    // ERROR: 'errorMessage' is still optional here. 'res.errorMessage' could be undefined.
    console.log(res.errorMessage.length);
  }
}
```

---

### Solution: Discriminated Union

````typescript
// Define the two possible response states as separate types
type SuccessResponse = {
  status: "Success"
  data: { id: string; name: string } // 'data' is REQUIRED
  errorMessage?: never // Ensure 'errorMessage' is not present
}

type ErrorResponse = {
  status: "Error"
  data?: never // Ensure 'data' is not present
  errorMessage: string // 'errorMessage' is REQUIRED
}

// The final type is a union of the two distinct states
type UserApiResponse = SuccessResponse | ErrorResponse

function handleResponse(res: UserApiResponse) {
  // Now, TypeScript can use the 'status' property as a discriminator
  if (res.status === "Success") {
    // Inside this block, 'res' is narrowed to 'SuccessResponse'.
    // 'res.data' is guaranteed to exist and is a non-optional object.
    console.log(res.data.name)
  } else {
    // Inside this block, 'res' is narrowed to 'ErrorResponse'.
    // 'res.errorMessage' is guaranteed to exist and is a non-optional string.
    console.log(res.errorMessage.length)
  }
}

* **Key Idea**: `status` acts as a **discriminator**.
* Inside each branch, TypeScript **narrows the type automatically**.
NOte -- we need to use Literal value not type like
in status : stirng (this will not work we have to give success error)


---

### Alternative: Using Switch Statement


```typescript
type SuccessResponse = {
  status: "Success"
  data: { id: string; name: string } // 'data' is REQUIRED
}

type ErrorResponse = {
  status: "Error"
  errorMessage: string // 'errorMessage' is REQUIRED
}

type UserApiResponse = SuccessResponse | ErrorResponse

function handleResponse(res: UserApiResponse) {
  switch (res.status) {
    case "Success":
      // Inside 'Success' case, 'res' is narrowed to 'SuccessResponse'.
      // res.data is guaranteed to exist.
      console.log(res.data.name);     // ‚úÖ safe
      break;
    case "Error":
      // Inside 'Error' case, 'res' is narrowed to 'ErrorResponse'.
      // res.errorMessage is guaranteed to exist.
      console.log(res.errorMessage);     // ‚úÖ safe
      break;
  }
}
````

- Switch statements are **interchangeable with if/else** for discriminated unions.
- Ensures **exhaustive checks** if using `never` type in default.

---

## üîπ Nuances & Best Practices

1. **Use literal types for the discriminator**:

   - `status: "Success"` ‚úÖ
   - `status: string` ‚ùå (will not narrow)

2. **Optional properties in base type** break narrowing ‚Üí define them in variant-specific types.
3. **`never` type** can be used for exhaustive checks:

   ```ts
   default:
     const exhaustiveCheck: never = res; // compiler error if any case is missing
   ```

4. Always **define separate types for each variant** ‚Üí clarity + type safety.

---

## ‚úÖ Summary

- **What**: Discriminated union allows safe type narrowing based on a literal property.
- **Why**: Optional fields in union types cannot be accessed safely without narrowing.
- **Where**: API responses, union types with variant-specific properties.
- **How**:

  - Define variant-specific types.
  - Use a literal property as a discriminator (`status`).
  - Use `if/else` or `switch` to safely narrow types.

- **Key Benefits**:

  - Eliminates optional property errors.
  - Automatic type narrowing.
  - Safer, more readable code.

---

# Video 38 ‚Äì Function Overloads

---

## üîπ What

- A **Function Overload** is when you define **multiple different call signatures** for a single function in TypeScript.
- Each overload signature specifies how the function can be called (parameter types, return type), but only one actual implementation is written.
- This allows the function to behave differently depending on the arguments provided, while still enforcing type safety.

---

## üîπ Why

- If we use **union types directly** in the parameters, the function becomes **too permissive**.
- Example (your initial code):

```ts
function sum(a: number | number[], b?: number) {}

const s1 = sum([1, 2], 3); // ‚úÖ valid
const s2 = sum(1, 2); // ‚úÖ valid
const s3 = sum(1); // ‚ùå but allowed incorrectly!
```

üëâ Here, `sum(1)` compiles, even though we never intended it.

- **Problem**: TypeScript cannot enforce which combinations are valid if we just use unions.
- **Solution**: Function overloads define **strict allowed call signatures**.

---

## üîπ Where

Function overloads are useful when:

1. A function needs to support **different argument shapes**.
2. Each shape should **enforce strict types** and disallow invalid calls.
3. You want **better return type inference** depending on parameters.

Examples:

- `Array.concat`, `Promise.resolve`, `addEventListener`.
- Utility functions like `sum`, `formatDate`, `parseResponse`.

---

## üîπ How

We fix your `sum` function using overloads.

### Step 1 ‚Äì Define Overload Signatures

```ts
// 1. Overload: array of numbers + optional number
function sum(nums: number[], b?: number): number;

// 2. Overload: two individual numbers
function sum(a: number, b: number): number;
```

‚ö° These **declare allowed calls**, but contain **no implementation**.

---

### Step 2 ‚Äì Single Implementation

```ts
function sum(a: number | number[], b?: number): number {
  if (Array.isArray(a)) {
    return a.reduce((total, current) => total + current, b || 0);
  } else {
    return a + (b || 0);
  }
}
```

- Implementation must accept a **union** that covers all overloads.
- Inside, we use **type narrowing** (`Array.isArray(a)`) to handle cases separately.

---

### Step 3 ‚Äì Usage

```ts
const s1 = sum([1, 2], 3); // ‚úÖ valid, uses overload 1
const s2 = sum(1, 2); // ‚úÖ valid, uses overload 2
const s3 = sum(1); // ‚ùå Error now! Not allowed
```

---

## üîπ Examples

### ‚ùå Without Overloads (Union Only)

```ts
function sum(a: number | number[], b?: number) {
  if (Array.isArray(a)) return a.reduce((t, c) => t + c, b || 0);
  return a + (b || 0);
}

sum([1, 2], 3); // ‚úÖ valid
sum(1, 2); // ‚úÖ valid
sum(1); // ‚ùå but incorrectly allowed
```

---

### ‚úÖ With Overloads

```typescript
// 1. Overload Signature 1: Handles an array of numbers and an optional second number
function sum(nums: number[], b?: number): number;

// 2. Overload Signature 2: Handles two individual numbers
function sum(a: number, b: number): number;

// 3. The Single Implementation Function: Must accept all possible types from the overloads
function sum(a: number | number[], b?: number): number {
  if (Array.isArray(a)) {
    // If 'a' is an array, perform array sum, including 'b' if present
    return a.reduce((total, current) => total + current, b || 0);
  } else {
    // If 'a' is a number, perform simple addition
    return a + (b || 0);
  }
}

// Usage (where TypeScript uses the correct overload signature)
const s1 = sum([1, 2], 3); // Uses Overload 1 (s1 is inferred as number)
const s2 = sum(1, 2); // Uses Overload 2 (s2 is inferred as number)
// const s3 = sum(1);      // Error: requires a second argument based on the signatures
```

---

## üîπ Nuances

1. **Only one implementation**:

   - All overloads share a single implementation body.

2. **Overload order matters**:

   - TypeScript resolves overloads top to bottom.

3. **Overloads vs Unions**:

   - Unions allow _all combinations_, including invalid ones.
   - Overloads allow _only explicitly defined call patterns_.

4. **Return types can differ**:

   - Overloads can be used to **narrow return type** based on inputs.

Example:

```ts
function getValue(id: number): string;
function getValue(name: string): number;
function getValue(input: number | string): string | number {
  return typeof input === "number" ? "value" : 123;
}

const a = getValue(1); // inferred as string
const b = getValue("x"); // inferred as number
```

---

## ‚úÖ Summary

- **What** ‚Üí Function overloads allow multiple call signatures for one function.
- **Why** ‚Üí Prevents invalid calls and ensures stricter type safety than unions.
- **Where** ‚Üí APIs, utilities, or any function with multiple valid input shapes.
- **How** ‚Üí

  1. Declare overload signatures (no body).
  2. Write one implementation covering all cases.
  3. Use type narrowing in the body.

- **Nuances** ‚Üí Only one implementation, order matters, stricter than unions, supports different return types.

---

Perfect! Let‚Äôs turn your **raw notes and code** into a **deep, structured, interview-friendly explanation** in the same style as before (What / Why / Where / How / Examples / Nuances / Summary), keeping your code intact and expanding the context.

---

# Video 39 ‚Äì Type Predicate (User-Defined Type Guards)

---

## üîπ What

- A **Type Predicate** (also called a **User-Defined Type Guard**) is a TypeScript feature that allows you to **narrow the type of a variable** when TypeScript cannot infer it automatically.
- It is used when **simple type narrowing** like `typeof` or `instanceof` is insufficient, or when working with **unknown or complex union types**.
- Syntax:

```ts
function isPerson(obj: Person | Todo): obj is Person { ... }
```

Here, `obj is Person` is the **type predicate**. It tells TypeScript:

> ‚ÄúIf this function returns true, treat `obj` as `Person` from now on.‚Äù

---

## üîπ Why

- TypeScript is strict when working with `unknown` or union types.
- Without type predicates, TypeScript may **not allow property access** even if we logically know the type.

Example without type predicate:

```ts
type Person = { name: string };
type Todo = { title: string };

function print(obj: unknown) {
  if ("name" in obj) {
    console.log(obj.name); // ‚ùå TS Error: 'obj' is unknown
  }
}
```

- Problem: TypeScript **doesn‚Äôt know** that `'name' in obj` means `obj` is a `Person`.
- Solution: **Create a user-defined type guard** using a type predicate.

---

## üîπ Where

- Whenever **TypeScript cannot automatically narrow** a union type.
- Scenarios:

  1. Checking if a variable is **one of multiple object types**.
  2. Narrowing **string unions** based on values (like `"High" | "Medium" | "Low"`).
  3. Working with **unknown** from APIs or external data.

---

## üîπ How

### Step 1 ‚Äì Define a Type Predicate Function

```ts
type Person = { name: string };
type Todo = { title: string };

// User-Defined Type Guard
function isPerson(obj: Person | Todo): obj is Person {
  return "name" in obj;
}
```

- `obj is Person` is key: it tells TypeScript that if this function returns `true`, `obj` is of type `Person`.

---

### Step 2 ‚Äì Use it in Functions

```ts
function print(obj: Person | Todo) {
  if (isPerson(obj)) {
    // TS now knows obj is Person
    console.log(obj.name);
    return;
  }

  // If the function hasn't returned, obj must be Todo
  console.log(obj.title);
}
```

- **Outcome**: TypeScript now understands the type inside each branch.
- Avoids manual casting or `as` assertions in multiple places.

---

### Step 3 ‚Äì Type Predicate with String Literal Unions

```typescript
const PRIORITIES = ["High", "Medium", "Low"] as const;
// Type is inferred as "High" | "Medium" | "Low"
type Priority = (typeof PRIORITIES)[number];

type Todo = {
  title: string;
  description: string;
};

function func(todo: Todo) {
  if (isPriority(todo.description)) {
    // Inside this block, todo.description is narrowed to type Priority ("High" | "Medium" | "Low")
    todo.description;
  } else {
    // Inside this block, todo.description remains the base type string (or any string not in Priority)
    todo.description;
  }
}

// User-Defined Type Predicate
function isPriority(description: string): description is Priority {
  // We use a type assertion ('as Priority') because the PRIORITIES.includes method
  // expects an argument compatible with the array's element type,
  // and 'description' is a general string.
  return PRIORITIES.includes(description as Priority);
}
```

---

## Note on Type Narrowing

Your note correctly suggests that **Type Predicates are often used when simple narrowing is impossible**. In this case, since `description` starts as a general `string`, simple checks like `typeof` or `instanceof` can't narrow it to a specific set of string literals (`"High" | "Medium" | "Low"`).

A type predicate (`description is Priority`) is the appropriate and most readable way to achieve this kind of custom, conditional type narrowing in TypeScript. Discriminatory unions are only useful when the data structure itself can be separated by a literal property (like `status: "Error"` or `status: "Success"`), which is not the case here, as `Priority` is a property _value_, not a type discriminator.

- Here, TypeScript **cannot infer** that a string belongs to a specific set of literals (`Priority`).
- Type predicate allows **custom logic** to narrow types based on runtime checks.

---

## üîπ Nuances

1. **Use type predicates when**:

   - Simple `typeof` / `instanceof` / `in` checks are insufficient.
   - You have **unknown / external data**.
   - You want **clean and reusable type narrowing**.

2. **Difference from `unknown` / `any`**:

   - `unknown` forces checks but is strict.
   - `any` bypasses TS checks entirely (unsafe).
   - Type predicates are **safe middle ground**: you tell TypeScript the type after verification.

3. **Combining with unions**:

   - Works perfectly with union types, **discriminated unions**, and string literal unions.
   - Allows fine-grained **runtime + compile-time type safety**.

4. **Avoid overly complex predicates**:

   - Keep the type-check logic clear; otherwise, debugging becomes difficult.

---

## ‚úÖ Summary

- **What** ‚Üí User-defined type predicate is a way to tell TypeScript ‚Äúthis variable is of type X if the function returns true.‚Äù
- **Why** ‚Üí TypeScript can‚Äôt always infer types, especially with `unknown` or union types.
- **Where** ‚Üí Unknown data, API responses, union types, string literal checks.
- **How** ‚Üí

  1. Write a function returning `obj is Type`.
  2. Implement a runtime check inside.
  3. Use it in `if` / `else` branches to narrow types safely.

- **Nuances** ‚Üí Safe alternative to `any`, works with unions, prevents unnecessary type assertions, and makes code readable.

---

Here‚Äôs Video 40 notes in your preferred structured, in-depth style:

---

# Video 40 ‚Äì Debugging TypeScript

### **What**

Debugging in TypeScript involves **finding and fixing type-related errors** at compile time, as well as runtime debugging for logic errors. TypeScript helps **catch mistakes before runtime**, but you still need strategies to efficiently debug both type issues and normal JavaScript logic.

---

### **Why**

- TypeScript‚Äôs static type system prevents many common bugs (e.g., property access on `undefined`, wrong function arguments).
- Sometimes, **complex types, unknowns, union types, or generics** create errors that are not immediately obvious.
- Proper debugging ensures **safer, predictable code** and helps during **interview discussions or production fixes**.

---

### **Where**

- While accessing **optional properties** or **union types**.
- When working with **unknown or any types**.
- When using **type assertions, type predicates, or discriminated unions**.
- During **fetching and parsing API responses** where types may not match expectations.

---

### **How**

1. **Use `tsc` to compile and check types**:

```bash
tsc filename.ts
```

- Shows all type errors before running code.
- Ensures you catch mistakes in function signatures, variable assignments, and property accesses.

2. **Leverage IDE type hints and errors**

- VSCode highlights type mismatches in real-time.
- Hover over variables to see inferred types.

3. **Add console logs for runtime debugging**

```ts
const todo: Todo = getTodo();
console.log(todo); // inspect structure
console.log(typeof todo.dueDate);
```

- Helps verify type assumptions at runtime.

4. **Use type narrowing to avoid errors**

```ts
if (typeof todo.dueDate === "string") {
  console.log(todo.dueDate.length); // safe
} else {
  console.log(todo.dueDate.getDate()); // safe for Date
}
```

5. **Use assertions carefully**

```ts
const form = document.querySelector<HTMLFormElement>(".form")!;
form.addEventListener("submit", () => {});
```

- `!` tells TypeScript the value is **never null**, bypassing optional checks.
- Debug carefully: misuse can hide real null issues.

6. **Debugging unknown types**

```ts
function print(obj: unknown) {
  if (typeof obj === "object" && obj !== null && "name" in obj) {
    console.log((obj as { name: string }).name);
  }
}
```

- Narrow unknown types step by step.
- Console logs can confirm runtime type assumptions.

7. **Using type predicates for complex conditions**

```ts
function isPerson(obj: unknown): obj is Person {
  return typeof obj === "object" && obj !== null && "name" in obj;
}

if (isPerson(obj)) {
  console.log(obj.name);
}
```

- Type predicates help TypeScript **understand your checks**, preventing false type errors.

---

### **Nuances**

- **Optional chaining (`?.`)** vs **non-null assertion (`!`)**:

  - `?.` = safe runtime access.
  - `!` = bypass TypeScript checks; use when you are **sure value exists**.

- **Unknown vs Any**:

  - `any` = no type checking; can hide errors.
  - `unknown` = forces explicit checks; safer.

- **Discriminated unions + type predicates** = powerful combo for debugging complex objects.

---

### **Summary**

- TypeScript debugging is a combination of **compile-time type checks** and **runtime inspection**.
- Always narrow types before accessing properties.
- Use **type predicates**, **optional chaining**, and **console logs** to debug effectively.
- Proper debugging prevents runtime errors and ensures your TS code is **safe, maintainable, and interview-friendly**.

---

---

Here‚Äôs Video 41 notes in your preferred structured, in-depth style:

---

# Video 41 ‚Äì Importing Types

### **What**

Importing types in TypeScript allows you to **reuse type definitions** across multiple files. This ensures **type safety**, avoids duplication, and keeps large projects organized.

---

### **Why**

- Avoid redefining the same type in multiple files.
- Maintain **consistency** in data structures.
- Improve **readability** and **maintainability** of code.
- Essential for **modular applications** or **library usage**.

---

### **Where**

- When splitting **interfaces, types, or enums** into separate files.
- When importing **types from npm packages** (e.g., `@types/node`).
- When working with **large projects** where types are shared across modules.

---

### **How**

1. **Export a type from a file**

```ts
// types.ts
export type Todo = {
  title: string;
  description?: string;
  isComplete: boolean;
};
```

2. **Import the type in another file**

```ts
// main.ts
import { Todo } from "./types";

const todo: Todo = {
  title: "Learn TypeScript",
  isComplete: false,
};
```

3. **Import multiple types**

```ts
// types.ts
export type User = {
  id: string;
  name: string;
};

export type Todo = {
  title: string;
  isComplete: boolean;
};

// main.ts
import { User, Todo } from "./types";
```

4. **Import type only (TS 3.8+)**

```ts
// main.ts
import type { Todo } from "./types";
// This ensures TypeScript imports only the type for compile-time checks
```

- Using `import type` **does not generate runtime code**.
- Useful for avoiding **circular dependencies** or **tree-shaking issues**.

5. **Renaming imported types**

```ts
import type { Todo as TodoType } from "./types";

const todo: TodoType = { title: "Read TS docs", isComplete: false };
```

---

### **Nuances**

- **`import type`** vs normal `import`:

  - `import type` = compile-time only, no JS output.
  - normal `import` = both compile-time and runtime code.

- Circular dependencies can still occur at runtime if **modules export values**, but **type-only imports** prevent that.
- Combining **default and named type exports**:

```ts
// types.ts
export default type Todo = { title: string; isComplete: boolean }
export type User = { id: string; name: string }

// main.ts
import Todo, { User } from './types'
```

- **Use type-only imports** wherever possible to **keep runtime clean**.

---

### **Summary**

- Type imports improve **code reuse, maintainability, and type safety**.
- Prefer **`import type`** for purely type imports to avoid runtime overhead.
- Always organize types in **dedicated files** for modular and scalable TypeScript projects.

---

---

# Video 42 ‚Äì Declaration Files

### **What**

Declaration files in TypeScript (`.d.ts`) are **type definition files** that describe the **shape of JavaScript code** to TypeScript. They provide type information **without containing actual implementation**.

- Used when **importing plain JavaScript code** into TypeScript.
- Also called **ambient declarations**.

---

### **Why**

- **Add type safety** to existing JavaScript libraries.
- Enable **TypeScript to understand JS modules** without rewriting them.
- Help editors provide **autocomplete, intellisense, and error checking**.
- Essential for **third-party libraries** that don‚Äôt include types.

---

### **Where**

- In **node_modules** (e.g., `@types/lodash`).
- In your project for **custom JS modules**.
- When writing a **library in JS** and providing TS users with **types**.

---

### **How**

1. **Basic Declaration File Example**

```ts
// math.d.ts
declare function add(a: number, b: number): number;
declare function multiply(a: number, b: number): number;
```

- Here, we declare two functions without providing implementations.
- TypeScript can now check types for code that calls these functions.

```ts
// main.ts
add(1, 2); // ‚úÖ OK
add(1, "2"); // ‚ùå Type Error
```

2. **Declaring a module**

```ts
// myLib.d.ts
declare module "my-lib" {
  export function greet(name: string): void;
}
```

- Useful for **importing JS libraries without types**.

```ts
import { greet } from "my-lib";
greet("Vipul"); // ‚úÖ Type-checked
```

3. **Declaring types for global variables**

```ts
// globals.d.ts
declare const API_URL: string;
```

- Now `API_URL` can be used anywhere without TS errors.

4. **Declaring interfaces or types**

```ts
// myTypes.d.ts
interface Todo {
  title: string;
  completed: boolean;
}
```

- Can be **imported in TypeScript files** just like regular types.

5. **Using `export` in declaration files**

```ts
// todo.d.ts
export interface Todo {
  title: string;
  completed: boolean;
}

// main.ts
import type { Todo } from "./todo";
const task: Todo = { title: "Learn TS", completed: false };
```

---

### **Nuances**

- `.d.ts` files **do not generate JS output**.
- Can declare **ambient modules** with `declare module` for JS libraries.
- **Triple-slash directives** (`/// <reference path="..." />`) can reference declaration files.
- Many libraries provide **@types packages** (DefinitelyTyped) so you don‚Äôt have to write declaration files manually.
- **Declaration merging** is supported: multiple `.d.ts` files with the same module can merge their types.

---

### **Summary**

- Declaration files give **TypeScript awareness of JS code**.
- They ensure **type safety** without changing JS implementation.
- Use `.d.ts` to describe functions, modules, globals, or types for **JS libraries or projects**.
- Always prefer **type-only imports and exports** when using declaration files in TS projects.

---

# Last Video ‚Äì Classes in TypeScript

Classes in TypeScript are similar to JavaScript classes, but **with added type safety**.
They allow you to define **blueprints for objects**, including properties, constructors, and methods, all strongly typed.

---

### ‚úÖ Example 1: Basic Class

```typescript
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(
      `Hello, my name is ${this.name} and I am ${this.age} years old.`
    );
  }
}

const p1 = new Person("Alice", 25);
p1.greet();
```

‚úî Here `name` and `age` are strongly typed.
‚úî The `constructor` initializes properties.
‚úî The `greet()` method has type inference: it always returns `void`.

---

### ‚úÖ Example 2: Access Modifiers

TypeScript introduces **modifiers** to control visibility:

```typescript
class Employee {
  public name: string; // accessible everywhere
  private salary: number; // accessible only inside class
  protected role: string; // accessible inside class & subclasses

  constructor(name: string, salary: number, role: string) {
    this.name = name;
    this.salary = salary;
    this.role = role;
  }

  getDetails() {
    return `${this.name} works as ${this.role}`;
  }
}

class Manager extends Employee {
  getRole() {
    return this.role; // ‚úÖ allowed because 'role' is protected
  }
}

const e1 = new Employee("Bob", 50000, "Developer");
console.log(e1.name); // ‚úÖ works
// console.log(e1.salary)  // ‚ùå Error: private
```

- **public** ‚Üí default, accessible everywhere
- **private** ‚Üí only inside class
- **protected** ‚Üí inside class & subclasses

---

### ‚úÖ Example 3: Readonly & Optional Properties

```typescript
class Car {
  readonly brand: string;
  model?: string; // optional property

  constructor(brand: string, model?: string) {
    this.brand = brand;
    this.model = model;
  }
}

const c1 = new Car("Tesla", "Model 3");
console.log(c1.brand); // Tesla
// c1.brand = "BMW"     // ‚ùå Error (readonly)
```

‚úî `readonly` makes property immutable.
‚úî `?` makes property optional.

---

### ‚úÖ Example 4: Implements Interface

Classes can **implement interfaces** to enforce a contract.

```typescript
interface Shape {
  getArea(): number;
}

class Circle implements Shape {
  radius: number;

  constructor(radius: number) {
    this.radius = radius;
  }

  getArea(): number {
    return Math.PI * this.radius * this.radius;
  }
}
```

‚úî Ensures `Circle` must provide a `getArea()` method.

---

### ‚úÖ Example 5: Abstract Classes

Abstract classes cannot be instantiated directly.
They provide a **base class** with methods that must be implemented by subclasses.

```typescript
abstract class Animal {
  abstract makeSound(): void;

  move() {
    console.log("Moving...");
  }
}

class Dog extends Animal {
  makeSound(): void {
    console.log("Woof Woof");
  }
}

const d = new Dog();
d.makeSound(); // Woof Woof
d.move(); // Moving...
```

‚úî `abstract` methods have no body ‚Üí must be implemented by subclass.

---

### ‚úÖ Example 6: Parameter Properties (Shortcut)

TypeScript allows you to **declare & assign class properties directly in the constructor**:

```typescript
class Student {
  constructor(public name: string, private grade: number) {}

  getGrade() {
    return this.grade;
  }
}

const s1 = new Student("John", 10);
console.log(s1.name); // John
// console.log(s1.grade)   // ‚ùå Error: private
```

‚úî No need to separately declare and assign.
‚úî Very common in modern TS.

---

## üîë Key Takeaways

1. Classes in TS are just JS classes **+ type annotations**.
2. Use **modifiers** (`public`, `private`, `protected`, `readonly`) for access control.
3. Classes can **implement interfaces** ‚Üí enforces structure.
4. **Abstract classes** are templates for subclasses.
5. Use **parameter properties** for clean code.

---

üëâ In **React + TS**, you will **rarely** write classes (since React now mostly uses **functional components + hooks**).
But you‚Äôll still see classes in:

- Older React projects (class components).
- External libraries (class-based APIs).
- OOP-heavy TypeScript apps (outside React).

---

-----------------------WHAT ARE USEFUL IN REACT-----------------------------

Perfect! Let‚Äôs go **video by video from your 42-video list**, marking which are **essential for React + TypeScript**, **optional**, or **rarely needed**.

---

### **React + TS Relevance by Video Number**

| Video No | Topic                                     | React Relevance                                |
| -------- | ----------------------------------------- | ---------------------------------------------- |
| 1        | Introduction to TS                        | Must-Know ‚úÖ                                   |
| 2        | Basic Types                               | Must-Know ‚úÖ                                   |
| 3        | Arrays, Tuples, Enums                     | Arrays & Enums: ‚úÖ, Tuples: Optional üü°        |
| 4        | Objects / Interfaces                      | Must-Know ‚úÖ                                   |
| 5        | Functions & Parameters                    | Must-Know ‚úÖ                                   |
| 6        | Optional & Default Params                 | Must-Know ‚úÖ                                   |
| 7        | Union & Intersection Types                | Union: ‚úÖ, Intersection (complex): Optional üü° |
| 8        | Type Aliases vs Interfaces                | Must-Know ‚úÖ                                   |
| 9        | Literal Types                             | Must-Know ‚úÖ                                   |
| 10       | Type Assertions (`as`)                    | Must-Know ‚úÖ                                   |
| 11       | Unknown Type                              | Must-Know ‚úÖ                                   |
| 12       | Never Type                                | Optional üü° (rarely needed in React)           |
| 13       | Type Guards                               | Must-Know ‚úÖ                                   |
| 14       | Discriminated Union                       | Must-Know ‚úÖ                                   |
| 15       | Function Overloads                        | Rarely Needed üü†                               |
| 16       | Generics                                  | Must-Know ‚úÖ                                   |
| 17       | Optional Chaining (`?.`) & Non-Null (`!`) | Must-Know ‚úÖ                                   |
| 18       | Satisfies Keyword                         | Optional üü°                                    |
| 19       | Index Signatures                          | Rarely Needed üü†                               |
| 20       | Mapped Types / Conditional Types          | Rarely Needed üü†                               |
| 21       | Importing Types                           | Must-Know ‚úÖ                                   |
| 22       | Declaration Files                         | Must-Know ‚úÖ                                   |
| 23       | Type Predicate / User-Defined Type Guards | Must-Know ‚úÖ                                   |
| 24       | Any Type                                  | Rarely Used ‚ö™ (try to avoid)                  |
| 25       | Debugging TypeScript                      | Optional üü°                                    |
| 26       | Class Types & Constructors                | Optional üü°                                    |
| 27       | Readonly & Const Assertions               | Optional üü°                                    |
| 28       | Partial & Required Utility Types          | Optional üü°                                    |
| 29       | Pick & Omit Utility Types                 | Optional üü°                                    |
| 30       | Record & Keyof                            | Optional üü°                                    |
| 31       | Typeof & Instanceof Guards                | Must-Know ‚úÖ                                   |
| 32       | Basic Type Guards                         | Must-Know ‚úÖ                                   |
| 33       | Never Type (exhaustive check)             | Optional üü°                                    |
| 34       | Unknown Type (advanced)                   | Must-Know ‚úÖ                                   |
| 35       | As Casting / Type Assertion               | Must-Know ‚úÖ                                   |
| 36       | Satisfies Keyword (advanced)              | Optional üü°                                    |
| 37       | Discriminated Union                       | Must-Know ‚úÖ                                   |
| 38       | Function Overloads (detailed)             | Rarely Needed üü†                               |
| 39       | Type Predicate                            | Must-Know ‚úÖ                                   |
| 40       | Debugging TypeScript                      | Optional üü°                                    |
| 41       | Importing Types                           | Must-Know ‚úÖ                                   |
| 42       | Declaration Files                         | Must-Know ‚úÖ                                   |

---

### ‚úÖ Key Takeaways

- **Must-Know for React + TS:** 1,2,3(arrays & enums),4,5,6,7(union),8,9,10,11,13,14,16,17,21,22,23,31,32,34,35,37,39,41,42
- **Optional / Advanced (learn when needed):** 3(tuples),7(intersection),12,18,25,26,27,28,29,30,33,36,40
- **Rarely Needed / Skip initially:** 15,19,20,24,38

---

0. [**Video 0 ‚Äì HOW TO Actually Use TypeScript with React**](#-video-0--how-to-actually-use-typescript-with-react) ‚≠ê \*_use this to go to top_
